{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Cpp Override is a C++ 11 Framework that allows you to override function behaviors. </p> <p>This allows testing in a per function basis instead of being forced to use classes,  though you can still use this framework to perform mocking in the traditional OOP way.</p> <p>We even ship with a mock class generator which parses a given header and gives back mock class you can use.</p> <p>Using the framework is very simple, after you declare an override instance, you just need to follow the \"Insert, Instruct, Inspect\" steps to setup and test your overridden functions.</p> <p>\ud83d\ude80 Features</p> <ul> <li>\u2699\ufe0f Override any classes you want, including non virtual classes</li> <li>\ud83d\udca1 Override any functions you want, including free functions</li> <li>\ud83d\udcd1 Doesn't break C++ Standard, no need to exploit vtable</li> <li>\ud83d\udd0c Easy to setup and use</li> <li>\ud83d\udd0b Batteries included, generate mock classes using the mock class generator</li> </ul>"},{"location":"example/","title":"Example","text":"<pre><code>#include \"CppOverride.hpp\"\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\nCO_DECLARE_INSTANCE(OverrideInstanceName);\n\nnamespace MyNameSpace\n{\n    int OverrideMyScopedFunc(int value1, float&amp; value2)\n    {\n        CO_INSERT_IMPL(OverrideInstanceName, int, (value1, value2));\n        //The rest of the implementations...\n        return 0;\n    }\n}\n\nint OverrideMyReturnValue(int value1, float value2)\n{\n    CO_INSERT_IMPL(OverrideInstanceName, int, (value1, value2));\n    //The rest of the implementations...\n    return 0;\n}\n\nint SomeRef = 0;\n\nint&amp; OverrideMyReturnRef(int value1, float value2)\n{\n    CO_INSERT_IMPL(OverrideInstanceName, int&amp;, (value1, value2));\n    //The rest of the implementations...\n    return SomeRef;\n}\n\nvoid OverrideMyArgs(float&amp; value1, int* value2)\n{\n    CO_INSERT_IMPL(OverrideInstanceName, void, (value1, value2));\n}\n\nbool OverrideMyArgsWithStstus(float&amp; value1, int* value2)\n{\n    CO_INSERT_IMPL(OverrideInstanceName, bool, (value1, value2));\n    return false;\n}\n\n#define CO_QUICK_ASSERT(expr)\\\ndo\\\n{\\\n    bool assertion = (expr);\\\n    if(assertion)\\\n    {\\\n        std::cout &lt;&lt; \"Assertion succeeded: \\\"\" &lt;&lt; #expr &lt;&lt; \"\\\"\" &lt;&lt; std::endl;\\\n    }\\\n    else\\\n    {\\\n        std::cerr &lt;&lt; \"Assertion failed: \\\"\" &lt;&lt; #expr &lt;&lt; \"\\\"\" &lt;&lt; std::endl;\\\n        exit(-1);\\\n    }\\\n} while(0)\n\nvoid ResetAll()\n{\n    CO_CLEAR_ALL_INSTRUCTS(OverrideInstanceName);\n}\n\nvoid OverrideReturnsExample()\n{\n    CO_INSTRUCT_REF(OverrideInstanceName, CO_GLOBAL, OverrideMyReturnValue).Returns&lt;int&gt;(1);\n\n    CO_QUICK_ASSERT(OverrideMyReturnValue(0, 0.f) == 1);\n\n    int returnRef = 1;\n    CO_INSTRUCT_REF(OverrideInstanceName, CO_GLOBAL, OverrideMyReturnRef).Returns&lt;int&amp;&gt;(returnRef);\n\n    CO_QUICK_ASSERT(&amp;returnRef == &amp;OverrideMyReturnRef(0, 0.f));\n\n    ResetAll();\n}\n\nvoid OverrideArgumentsExample()\n{\n    CO_INSTRUCT_REF(OverrideInstanceName, CO_GLOBAL, OverrideMyArgs).SetArgs&lt;float&amp;, int*&gt;(1.f, 3);\n\n    float arg1 = 0.f;\n    int arg2 = 0;\n    OverrideMyArgs(arg1, &amp;arg2);\n    CO_QUICK_ASSERT(arg1 == 1.f);\n    CO_QUICK_ASSERT(arg2 == 3);\n\n    ResetAll();\n}\n\nvoid OverrideScopedFunctionExample()\n{\n    CO_INSTRUCT_REF(OverrideInstanceName, MyNameSpace, OverrideMyScopedFunc).Returns&lt;int&gt;(1);\n\n    float floatArg = 0.f;\n    CO_QUICK_ASSERT(MyNameSpace::OverrideMyScopedFunc(1, floatArg) == 1);\n\n    CO_REMOVE_INSTRUCT_REF(OverrideInstanceName, MyNameSpace, OverrideMyScopedFunc);\n\n    CO_INSTRUCT_REF (OverrideInstanceName, MyNameSpace, OverrideMyScopedFunc)\n                    .SetArgs&lt;CO_ANY_TYPE, float&amp;&gt;(CO_DONT_SET, 3);\n\n    MyNameSpace::OverrideMyScopedFunc(1, floatArg);\n    CO_QUICK_ASSERT(floatArg == 3);\n}\n\nvoid OverrideReturnsWithActionLambda()\n{\n    CO_INSTRUCT_REF (OverrideInstanceName, CO_GLOBAL, OverrideMyReturnValue)\n                    .ReturnsByAction&lt;int&gt;\n                    ( \n                        []( void*, \n                            const std::vector&lt;CppOverride::TypedDataInfo&gt;&amp; args, \n                            const CppOverride::TypedInfo&amp; returnInfo) -&gt; CppOverride::TypedDataInfo\n                        { \n                            (void)args;\n                            //Can access args with type safety if needed\n                            //e.g., if(args.at(0).IsType&lt;int&gt;()) { ... }\n\n                            //When returning a value, you should use CreateValue&lt;int&gt;(int value)\n                            if(returnInfo.IsType&lt;int&gt;())\n                                return CppOverride::TypedDataInfo().CreateValue&lt;int&gt;(5);\n\n                            //When returning a reference, \n                            //you should use CreateReference&lt;int&amp;&gt;(int* valuePtr)\n\n                            return CppOverride::TypedDataInfo();\n                        }\n                    );\n\n    CO_QUICK_ASSERT(OverrideMyReturnValue(0, 0.f) == 5);\n\n    ResetAll();\n}\n\nvoid OverrideArgumentsWithActionLambda()\n{\n    CO_INSTRUCT_REF (OverrideInstanceName, CO_GLOBAL, OverrideMyArgs)\n                    .SetArgsByAction&lt;float&amp;, int*&gt;\n                    (\n                        [](void*, std::vector&lt;CppOverride::TypedDataInfo&gt;&amp; args)\n                        {\n                            if(args.at(0).IsType&lt;float&gt;())\n                                *args.at(0).GetTypedDataPtr&lt;float&gt;() = 1.f;\n                            if(args.at(1).IsType&lt;int*&gt;())\n                                **args.at(1).GetTypedDataPtr&lt;int*&gt;() = 2;\n                        }\n                    );\n\n    float arg1 = 0.f;\n    int arg2 = 0;\n    OverrideMyArgs(arg1, &amp;arg2);\n    CO_QUICK_ASSERT(arg1 == 1.f);\n    CO_QUICK_ASSERT(arg2 == 2);\n\n    ResetAll();\n}\n\nvoid WhenCalledWithExample()\n{\n    CO_INSTRUCT_REF (OverrideInstanceName, CO_GLOBAL, OverrideMyReturnValue)\n                    .WhenCalledWith(2, 3.f)\n                    .Returns&lt;int&gt;(1);\n\n    int ret1 = OverrideMyReturnValue(2, 3.f);   //Returns 1\n    int ret2 = OverrideMyReturnValue(1, 2.f);   //Won't return 1\n\n    CO_QUICK_ASSERT(ret1 == 1);\n    CO_QUICK_ASSERT(ret2 != 1);\n\n    ResetAll();\n}\n\nvoid TimesExample()\n{\n    CO_INSTRUCT_REF (OverrideInstanceName, CO_GLOBAL, OverrideMyArgs)\n                    .SetArgs&lt;float&amp;, int*&gt;(1.f, 2)\n                    .Times(1);\n\n    float testFloat = 2.f;\n    int testInt = 3;\n    OverrideMyArgs(testFloat, &amp;testInt);    //The argument values are set to 1.f and 2\n\n    CO_QUICK_ASSERT(testFloat == 1.f);\n    CO_QUICK_ASSERT(testInt == 2);\n\n    testFloat = 2.f;\n    testInt = 3;\n    OverrideMyArgs(testFloat, &amp;testInt);    //The argument values are still 2.f and 3\n\n    CO_QUICK_ASSERT(testFloat == 2.f);\n    CO_QUICK_ASSERT(testInt == 3);\n\n    ResetAll();\n}\n\nvoid IfConditionLambdaExample()\n{\n    CO_INSTRUCT_REF (OverrideInstanceName, CO_GLOBAL, OverrideMyReturnValue)\n                    .If\n                    (\n                        [](void*, const std::vector&lt;CppOverride::TypedDataInfo&gt;&amp; args)\n                        {\n                            if(args.at(0).IsType&lt;int&gt;() &amp;&amp; *args.at(0).GetTypedDataPtr&lt;int&gt;() == 1)\n                                return true;\n                            else\n                                return false;\n                        }\n                    )\n                    .Returns&lt;int&gt;(1);\n\n    int ret1 = OverrideMyReturnValue(1, 2.f);   //Returns 1\n    int ret2 = OverrideMyReturnValue(2, 3.f);   //Won't return 1\n\n    CO_QUICK_ASSERT(ret1 == 1);\n    CO_QUICK_ASSERT(ret2 != 1);\n\n    ResetAll();\n}\n\nvoid WhenCalledExpectedlyDoLambdaExample()\n{\n    bool called = false;\n    CO_INSTRUCT_REF (OverrideInstanceName, CO_GLOBAL, OverrideMyReturnValue)\n                    .WhenCalledWith(2, 3.f)\n                    .Returns&lt;int&gt;(1)\n                    .WhenCalledExpectedly_Do\n                    (\n                        [&amp;called](  void* instance, \n                                    const std::vector&lt;CppOverride::TypedDataInfo&gt;&amp; args)\n                        {\n                            (void)instance;\n                            (void)args;\n                            //Can access args with type safety if needed\n                            //e.g., if(args.at(0).IsType&lt;int&gt;()) { ... }\n\n                            called = true;\n                        }\n                    );\n\n    int ret1 = OverrideMyReturnValue(2, 3.f);   //Returns 1 and sets called to true\n    CO_QUICK_ASSERT(ret1 == 1);\n    CO_QUICK_ASSERT(called == true);\n\n    ResetAll();\n}\n\nvoid OtherwiseDoLambdaExample()\n{\n    bool called = false;\n    CO_INSTRUCT_REF (OverrideInstanceName, CO_GLOBAL, OverrideMyReturnValue)\n                    .WhenCalledWith(2, 3.f)\n                    .Returns&lt;int&gt;(1)\n                    .Otherwise_Do\n                    (\n                        [&amp;called](  void* instance, \n                                    const std::vector&lt;CppOverride::TypedDataInfo&gt;&amp; args)\n                        {\n                            (void)instance;\n                            (void)args;\n                            //Can access args with type safety if needed\n                            //e.g., if(args.at(0).IsType&lt;int&gt;()) { ... }\n\n                            called = true;\n                        }\n                    );\n\n    int ret1 = OverrideMyReturnValue(1, 2.f);   //Won't return 1\n    CO_QUICK_ASSERT(ret1 != 1);\n    CO_QUICK_ASSERT(called == true);\n\n    ResetAll();\n}\n\nvoid AssignStatusExample()\n{\n    CppOverride::ResultPtr result;\n    CO_INSTRUCT_REF (OverrideInstanceName, CO_GLOBAL, OverrideMyReturnValue)\n                    .WhenCalledWith(2, 3.f)\n                    .Returns&lt;int&gt;(1)\n                    .AssignsResult(result);\n\n    int ret1 = OverrideMyReturnValue(1, 2.f);\n\n    //status will be OverrideStatus::MATCHING_CONDITION_VALUE_FAILED\n    CO_QUICK_ASSERT(ret1 != 1);\n    CO_QUICK_ASSERT(result-&gt;GetLastStatus() == \n                    CppOverride::OverrideStatus::MATCHING_CONDITION_VALUE_FAILED);\n\n    ResetAll();\n}\n\nvoid ExpectedExample()\n{\n    CO_INSTRUCT_REF (OverrideInstanceName, CO_GLOBAL, OverrideMyReturnValue)\n                    .WhenCalledWith(2, 3.f)\n                    .Times(1)\n                    .Returns&lt;int&gt;(1)\n                    .Expected();\n\n    CO_INSTRUCT_REF (OverrideInstanceName, CO_GLOBAL, OverrideMyReturnValue)\n                    .WhenCalledWith(3, 4.f)\n                    .Returns&lt;int&gt;(1)\n                    .ExpectedNotSatisfied();\n\n    std::vector&lt;CppOverride::FunctionName&gt; failedFunctions;\n\n    //Not triggering any instructed overrides when we expected to do so, \n    //therefore failed expectations.\n    int ret1 = OverrideMyReturnValue(1, 2.f);\n    failedFunctions = CO_GET_FAILED_EXPECTS(OverrideInstanceName);\n    CO_QUICK_ASSERT(ret1 != 1);\n    CO_QUICK_ASSERT(failedFunctions.size() == 1);\n\n    //Triggered the first instructed override, filled all expectations.\n    ret1 = OverrideMyReturnValue(2, 3.f);\n    failedFunctions = CO_GET_FAILED_EXPECTS(OverrideInstanceName);\n    CO_QUICK_ASSERT(ret1 == 1);\n    CO_QUICK_ASSERT(failedFunctions.empty());\n\n    //Triggered the second instructed override when we expect to not be triggered, \n    //therefore failing expectation\n    OverrideMyReturnValue(3, 4.f);\n    failedFunctions = CO_GET_FAILED_EXPECTS(OverrideInstanceName);\n    CO_QUICK_ASSERT(failedFunctions.size() == 1);\n\n    ResetAll();\n}\n\nint main(int, char**)\n{\n    OverrideReturnsExample();\n\n    OverrideArgumentsExample();\n\n    OverrideScopedFunctionExample();\n\n    OverrideReturnsWithActionLambda();\n\n    OverrideArgumentsWithActionLambda();\n\n    WhenCalledWithExample();\n\n    IfConditionLambdaExample();\n\n    WhenCalledExpectedlyDoLambdaExample();\n\n    OtherwiseDoLambdaExample();\n\n    AssignStatusExample();\n\n    ExpectedExample();\n\n    std::cout &lt;&lt; \"All examples are running correctly\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>","boost":-1},{"location":"getting_started/","title":"1. Getting Started","text":""},{"location":"getting_started/#1-installation","title":"1. Installation","text":"<p>Cpp Override is hosted on github at  https://github.com/Neko-Box-Coder/CppOverride.  Feel free to check out the source code yourself.</p> <p>To start off, you first need to clone (git submodule) the repository to a location of your choice. <pre><code># Submodule\ngit submodule add https://github.com/Neko-Box-Coder/CppOverride.git &lt;folder name&gt;\ngit submodule update --init --recursive\n\n# Cloning\ngit clone --recursive https://github.com/Neko-Box-Coder/CppOverride.git\n</code></pre></p> <p>This framework is header only so you can just include it with</p> <p><code>CppOverride.hpp</code> in <code>Include_SingleHeader</code> or <code>Include_MultiHeader</code></p> <p>Additionally, you can add the include directory with</p> <pre><code>add_subdirectory(CppOverride)\ntarget_link_libraries(YourTarget CppOverride)\n</code></pre>"},{"location":"getting_started/#2-override-behavior","title":"2. Override Behavior","text":"<p>CppOverride uses the \"Insert, Instruct, Inspect\" phases.</p> <p>The override works by inserting override logic at the beginning of a function. </p> <p>Then, the user can instruct how the overrides behave. The override perform \"passthrough\"  where it will do nothing and continue execution for the rest of the function if no instructs are given for that function.</p> <p>Finally, the user can inspect overrides results that do not meet the expectations.</p> <p>Since CppOverride is a macro driven framework, you can disable all macros by just defining  <code>CO_NO_OVERRIDE</code> to 1 or true. </p> <pre><code>#define CO_NO_OVERRIDE 1\n#include \"CppOverride.hpp\"\n</code></pre> <p>This way, you only need to pay for the functions you need to override  and not anything else.</p>"},{"location":"getting_started/#3-declare-override-instance","title":"3. Declare Override Instance","text":"<p>In order to override anything, we need to declare an override instance to store all the  override information that the function and test can reference from.</p>"},{"location":"getting_started/#global-file-scope-recommended","title":"Global / File Scope (Recommended)","text":"<p>Declaring it in global scope makes it easy to be accessed from both the function and the test.</p> <pre><code>CO_DECLARE_INSTANCE(OverrideObjName);\n\n//Or this if you want to reference an instance defined somewhere else\nextern CO_DECLARE_INSTANCE(OverrideObjName);\n</code></pre>"},{"location":"getting_started/#class-scope","title":"Class Scope","text":"<p>Declaring it in class scope is more similar to the traditional mock class approach</p> <p>You can do so by inheriting from <code>CppOverride::Overridable</code></p> <pre><code>class YourClass : public CppOverride::Overridable\n</code></pre> <p>In this case, you can just pass <code>*this</code> as the override instance, or the instance name you declared  for the class. </p>"},{"location":"getting_started/#4-quick-start","title":"4. Quick Start","text":""},{"location":"getting_started/#override-free-function","title":"\ud83d\udca1 Override Free Function","text":"<pre><code>#include &lt;iostream&gt;\n\n//Define CO_NO_OVERRIDE to disable overriding\n//#define CO_NO_OVERRIDE\n#include \"CppOverride.hpp\"\n\nCO_DECLARE_INSTANCE(OverrideInstance);\n\nint FreeFunction(int value1)\n{\n    CO_INSERT_IMPL(OverrideInstance, int, (value1));\n    return value1 * 2;\n}\n\n//Or CO_INSERT_METHOD(OverrideInstance, int, FreeFunction, (int));\n\nint main()\n{\n    CO_INSTRUCT_REF(OverrideInstance, CO_GLOBAL, FreeFunction)\n                   .WhenCalledWith(5)\n                   .Times(1)\n                   .Returns&lt;int&gt;(1);\n\n    //FreeFunction(0): 0\n    std::cout &lt;&lt; \"FreeFunction(0): \" &lt;&lt; FreeFunction(0) &lt;&lt; std::endl;\n\n    //FreeFunction(5): 1\n    std::cout &lt;&lt; \"FreeFunction(5): \" &lt;&lt; FreeFunction(5) &lt;&lt; std::endl;\n\n    //FreeFunction(5): 10\n    std::cout &lt;&lt; \"FreeFunction(5): \" &lt;&lt; FreeFunction(5) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"getting_started/#override-class-function","title":"\u2699\ufe0f Override Class Function","text":"<pre><code>class DummyMockClass : public CppOverride::Overridable\n{\n    public:\n        //int MemberFunction(int value1);\n        CO_INSERT_MEMBER_METHOD(*this, int, MemberFunction, (int))\n};\n\nint main()\n{\n    DummyMockClass dummyObject;\n\n    CO_INSTRUCT_REF(dummyObject, DummyMockClass, MemberFunction)\n                   .WhenCalledWith(5)\n                   .Times(1)\n                   .Returns&lt;int&gt;(1);\n\n    //dummyObject.MemberFunction(0): 0\n    std::cout &lt;&lt; \"dummyObject.MemberFunction(0): \" &lt;&lt; dummyObject.MemberFunction(0) &lt;&lt; std::endl;\n\n    //dummyObject.MemberFunction(5): 1\n    std::cout &lt;&lt; \"dummyObject.MemberFunction(5): \" &lt;&lt; dummyObject.MemberFunction(5) &lt;&lt; std::endl;\n\n    //dummyObject.MemberFunction(5): 5\n    std::cout &lt;&lt; \"dummyObject.MemberFunction(5): \" &lt;&lt; dummyObject.MemberFunction(5) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>This is just a quick taste on what it looks like.  There are many other things you can do. </p>"},{"location":"insert_overrides/","title":"2. Insert Overrides","text":"<p>After declaring the override instance, we are now ready to override any function using override implementations macros.</p>"},{"location":"insert_overrides/#overriding-existing-methods","title":"Overriding Existing Methods","text":"<p>CppOverride works by inserting an interception macro at the beginning of a function that  intercepts the rest of the logic of a function.</p> <p>This works for any functions you control. For external functions such as ones from the standard  library, you can work around it by using macro, which we will cover later in this documentation.</p> <p>To insert an override for a free function, simply use</p> <pre><code>CO_INSERT_IMPL(overrideInstance, returnType, (argument0, argument1, ...));\n</code></pre> Example <pre><code>    extern CO_DECLARE_INSTANCE(MyOverrideInstance);\n\n    int MyFreeFunction(int arg1, char* arg2, const std::string&amp; arg3)\n    {\n        CO_INSERT_IMPL(MyOverrideInstance, int, (arg1, arg2, arg3));\n        //Rest of function logic...\n        return 0;\n    }\n</code></pre> <p>Warning</p> <p>If you have comma in your return type (such as <code>std::tuple&lt;int, int&gt;</code>), you need to add an extra parenthesis to protect it against macro.</p> <p>For example: <pre><code>//std::tuple&lt;int, int&gt; FreeFunction(std::tuple&lt;int, int&gt; value1, float value2)\nCO_INSERT_IMPL(MyOverrideInstance, (std::tuple&lt;int, int&gt;), (value1, value2));\n</code></pre></p> <p>For class member functions, there are different versions of macro depending what you want to insert  the override.</p> <p>For normal member function, it works exactly like <code>CO_INSERT_IMPL</code>, except this macro records the  address of the object as well (<code>this</code>) which you can match against during instructing the override.</p> <pre><code>CO_INSERT_MEMBER_IMPL(overrideInstance, returnType, (arg0, arg1, ...));\n</code></pre> <p>For constructor and destructor however, a different macro is needed since they don't return anything.</p> <pre><code>CO_INSERT_MEMBER_IMPL_CTOR_DTOR(overrideInstance, (arg0, arg1, ...));\n</code></pre> <p></p>"},{"location":"insert_overrides/#creating-mock-methods","title":"Creating Mock Methods","text":"<p>If you want methods that only contains the <code>CO_INSERT_*_IMPL*</code> macros, we provide corresponding  macros that create it for you so you don't have to write the whole function by hand.</p> <p>We also have a rough mock class generator which generates mock class file by parsing an existing  header that you provider, this will be covered later in this documentation.</p> <p>To create an inline free mock function implementation, an overloaded macro is provided for you which automatically inserts <code>CO_INSERT_IMPL</code> macro.</p> <pre><code>CO_INSERT_METHOD(overrideInstance, returnType, functionName, (argType0, argType1, ...))\nCO_INSERT_METHOD(overrideInstance, returnType, functionName, (argType0, argType1, ...), prepend)\nCO_INSERT_METHOD(overrideInstance, returnType, functionName, (argType0, argType1, ...), prepend, append)\nCO_INSERT_METHOD(overrideInstance, returnType, functionName, (argType0, argType1, ...), prepend, append, \n    (defaultArg0, defaultArg1, ...))\n</code></pre> <p>Warning</p> <p>If you have comma in your argument or return types (such as <code>std::tuple&lt;int, int&gt;</code>), you  need to add an extra parenthesis to protect it against macro.</p> <p>For example: <pre><code>//std::tuple&lt;int, int&gt; FreeFunction(std::tuple&lt;int, int&gt; value1, float value2)\nCO_INSERT_METHOD(MyOverrideInstance, (std::tuple&lt;int, int&gt;), FreeFunction, ((std::tuple&lt;int, int&gt;), float))\n</code></pre></p> Example <pre><code>    extern CO_DECLARE_INSTANCE(MyOverrideInstance);\n\n    CO_INSERT_METHOD(MyOverrideInstance,                             //overrideInstance\n                     int,                                            //returnType\n                     MyFreeFunction,                                 //functionName\n                     (int, char*, const std::string&amp;),               //args\n                     static,                                         //prepend\n                     noexcept,                                       //append\n                     (/* no default */, = nullptr, = \"default\"));    //defaults\n\n    //Generated function\n    static inline int MyFreeFunction(int arg1, \n                                     char* arg2 = nullptr, \n                                     const std::string&amp; arg3 = \"default\") noexcept\n    {\n        CO_INSERT_IMPL(MyOverrideInstance, int, (arg1, arg2, arg3));\n        return int();\n    }\n</code></pre> <p>For member constructor and desturctor functions, there's <code>CO_INSERT_MEMBER_METHOD_CTOR</code> and  <code>CO_INSERT_MEMBER_METHOD_DTOR</code> which automatically inserts <code>CO_INSERT_MEMBER_IMPL_CTOR_DTOR</code> macro.</p> <p>Similar to <code>CO_OVERRIDE_METHOD</code>, it is overloaded with the same arguments.</p> <pre><code>CO_INSERT_MEMBER_METHOD_CTOR(overrideInstance, className, (argType0, argType1, ...))\nCO_INSERT_MEMBER_METHOD_CTOR(overrideInstance, className, (argType0, argType1, ...), prepend)\nCO_INSERT_MEMBER_METHOD_CTOR(overrideInstance, className, (argType0, argType1, ...), prepend, append)\nCO_INSERT_MEMBER_METHOD_CTOR(overrideInstance, className, (argType0, argType1, ...), prepend, append, \n    (defaultArg0, defaultArg1, ...))\n\nCO_INSERT_MEMBER_METHOD_DTOR(overrideInstance, className)\nCO_INSERT_MEMBER_METHOD_DTOR(overrideInstance, className, prepend)\nCO_INSERT_MEMBER_METHOD_DTOR(overrideInstance, className, prepend, append)\n</code></pre> Example <pre><code>    extern CO_DECLARE_INSTANCE(MyOverrideInstance);\n\n    class YourClass\n    {\n        CO_INSERT_MEMBER_METHOD_CTOR(MyOverrideInstance, YourClass, (int, float))\n        CO_INSERT_MEMBER_METHOD_DTOR(MyOverrideInstance, YourClass)\n\n        /*Generates\n        inline YourClass::YourClass(int arg1, float arg2)\n        {\n            CO_INSERT_MEMBER_IMPL_CTOR_DTOR(MyOverrideInstance, (arg1, arg2));\n        }\n\n        inline YourClass::~YourClass()\n        {\n            CO_INSERT_MEMBER_IMPL_CTOR_DTOR(MyOverrideInstance, ());\n        }\n        */\n    }\n</code></pre> <p>For inline member mock function implementation, an overloaded macro is provided which automatically inserts <code>CO_INSERT_MEMBER_IMPL</code> macro.</p> <pre><code>CO_INSERT_MEMBER_METHOD(overrideInstance, returnType, functionName, (argType0, argType1, ...))\nCO_INSERT_MEMBER_METHOD(overrideInstance, returnType, functionName, (argType0, argType1, ...), prepend)\nCO_INSERT_MEMBER_METHOD(overrideInstance, returnType, functionName, (argType0, argType1, ...), prepend, append)  \nCO_INSERT_MEMBER_METHOD(overrideInstance, returnType, functionName, (argType0, argType1, ...), prepend, append, \n    (defaultArg0, defaultArg1, ...))\n</code></pre> Example <pre><code>    extern CO_DECLARE_INSTANCE(MyOverrideInstance);\n\n    class MockMyClass : public MyClass\n    {\n        //int MemberFunction(int value1, float value2)\n        CO_INSERT_MEMBER_METHOD(MyOverrideInstance, int, MemberFunction, (int, float))\n\n        //void MemberFunction2(float&amp; value1, int* value2) const\n        CO_INSERT_MEMBER_METHOD(MyOverrideInstance, void, MemberFunction2, (float&amp;, int*), \n            /* no prepend */, const)\n\n        //virtual int MemberFunction3(int value1, float value2 = 1.f) const override\n        CO_INSERT_MEMBER_METHOD(MyOverrideInstance, int, MemberFunction3, (int, float), \n            virtual, const override, (/* no default */, = 1.f))\n    };\n</code></pre>"},{"location":"inspect_overrides/","title":"4. Inspect Override Expectations","text":"<p>After finish running the overrided functions, you can inspect what functions did not meet the expectations you set during the instruct phase.</p> <p></p>"},{"location":"inspect_overrides/#check-failed-expectations","title":"Check Failed Expectations","text":"<p>Use <code>CO_GET_FAILED_EXPECTS</code> to get a list of functions that failed to meet their expectations:</p> <pre><code>std::vector&lt;std::string&gt; failedFunctions = CO_GET_FAILED_EXPECTS(overrideInstance);\n</code></pre> <p>This returns a vector of function names (as strings) that - Failed the <code>.Expected()</code> checks - Failed the <code>.ExpectedNotSatisfy()</code> checks</p> <p>In addition to that, if passthrough doesn't meet the expectation but cannot contribute to any  specific function (Say must passthrough 5 times, but only passthrough 3 times), then the string <code>\"Passthrough\"</code> will be added to the vector. Otherwise, the string <code>\"(Passthrough)\"</code> will be  appended to the functions that contributes to the failure of the expectation.</p> Example <pre><code>CO_DECLARE_INSTANCE(MyOverrideInstance);\n\n//Set up expectations\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .WhenCalledWith(42)\n               .Returns&lt;int&gt;(100)\n               .Times(2)\n               .Expected();\n\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, AnotherFunction)\n               .Returns&lt;void&gt;()\n               .ExpectedNotSatisfy();\n\n//Run your code\nMyFunction(42);        //Called once, but expected twice\nAnotherFunction();     //Called, but expected not to be called\n\n//Check for failed expectations\nstd::vector&lt;std::string&gt; failed = CO_GET_FAILED_EXPECTS(MyOverrideInstance);\n\nif(!failed.empty())\n{\n    std::cout &lt;&lt; \"Failed expectations:\" &lt;&lt; std::endl;\n    for(const std::string&amp; funcName : failed)\n    {\n        std::cout &lt;&lt; \"- \" &lt;&lt; funcName &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p></p>"},{"location":"inspect_overrides/#debug-override-logs","title":"Debug Override Logs","text":"<p>If for any reason, it is unclear why the override did not get triggered and the override result did not give any useful information. You can force CppOverride to output verbose logs by defining <code>CO_SHOW_OVERRIDE_LOG 1</code> before <code>#include \"CppOverride.hpp\"</code>. </p> <p>This will show all the debug logs on each stage of selecting override data and what conditions  are not met.</p> <p></p>"},{"location":"inspect_overrides/#override-result","title":"Override Result","text":"<p><code>CppOverride::ResultPtr</code> is just a shared_ptr defined as this </p> <pre><code>using ResultPtr = std::shared_ptr&lt;OverrideResult&gt;;\n</code></pre> <p>Each time when there's an override attempt (whether successful or not),  it will add to the list of override status.</p> <p>To get the list of status: <pre><code>std::vector&lt;OverrideStatus&gt; statuses = result.GetAllStatuses();\n</code></pre></p> <code>OverrideResult.hpp</code> <pre><code>#ifndef CO_OVERRIDE_RESULT_HPP\n#define CO_OVERRIDE_RESULT_HPP\n\n#include \"./OverrideStatus.hpp\"\n\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n\nnamespace CppOverride\n{\n    class OverrideResult\n    {\n        private:\n            std::vector&lt;OverrideStatus&gt; Statuses;\n\n        public:\n            inline void AddStatus(OverrideStatus status)\n            {\n                Statuses.push_back(status);\n            }\n\n            inline void ClearStatuses()\n            {\n                Statuses.clear();\n            }\n\n            inline std::vector&lt;OverrideStatus&gt; GetAllStatuses()\n            {\n                return Statuses;\n            }\n\n            //Helpers\n            inline int GetSucceedCount()\n            {\n                int succeedCounter = 0;\n                for(size_t i = 0; i &lt; Statuses.size(); ++i)\n                {\n                    if(Statuses.at(i) == OverrideStatus::OVERRIDE_SUCCESS)\n                        ++succeedCounter;\n                }\n\n                return succeedCounter;\n            }\n\n            inline int GetFailedCount()\n            {\n                int failedCounter = 0;\n                for(size_t i = 0; i &lt; Statuses.size(); ++i)\n                {\n                    if(Statuses.at(i) != OverrideStatus::OVERRIDE_SUCCESS)\n                        ++failedCounter;\n                }\n\n                return failedCounter;\n            }\n\n            inline int GetStatusCount()\n            {\n                return (int)Statuses.size();\n            }\n\n            inline bool LastStatusSucceed()\n            {\n                return  Statuses.empty() ? \n                        false : \n                        Statuses.back() == OverrideStatus::OVERRIDE_SUCCESS;\n            }\n\n            inline bool LastStatusFailed()\n            {\n                return  Statuses.empty() ? \n                        false : \n                        Statuses.back() != OverrideStatus::OVERRIDE_SUCCESS;\n            }\n\n            inline OverrideStatus GetLastStatus()\n            {\n                return  Statuses.empty() ? OverrideStatus::NO_OVERRIDE : Statuses.back();\n            }\n\n            inline bool HasStatus(OverrideStatus status)\n            {\n                for(size_t i = 0; i &lt; Statuses.size(); ++i)\n                {\n                    if(Statuses.at(i) == status)\n                        return true;\n                }\n\n                return false;\n            }\n    };\n\n    using ResultPtr = std::shared_ptr&lt;OverrideResult&gt;;\n\n    inline ResultPtr CreateOverrideResult()\n    {\n        return std::make_shared&lt;OverrideResult&gt;();\n    }\n}\n\n#endif\n</code></pre> List of possible status <code>OverrideStatus.hpp</code> <pre><code>#ifndef CO_OVERRIDE_STATUS_HPP\n#define CO_OVERRIDE_STATUS_HPP\n\n#include &lt;string&gt;\n\nnamespace CppOverride\n{\n    enum class OverrideStatus\n    {\n        //------------------------------------------\n        //Override status\n        //------------------------------------------\n        //Default status.\n        //  Any matching override will modify the status to not be this value.\n        //  If the status is not modified (i.e. staying in this value), \n        //  Could be one of these reasons:\n        //  - Function name not matching\n        //  - Argument types not matching\n        //  - Return type not matching\n        NO_OVERRIDE,\n\n        //The last override was successful\n        OVERRIDE_SUCCESS,\n\n        MATCHING_CONDITION_VALUE_FAILED,\n        MATCHING_CONDITION_ACTION_FAILED,\n        MATCHING_OVERRIDE_TIMES_FAILED,\n        RETURN_ACTION_TYPE_MISMATCH,\n\n        //------------------------------------------\n        //Internal error\n        //------------------------------------------\n        INTERNAL_MISSING_CHECK_ERROR,\n\n        //------------------------------------------\n        //Unsupported operation errors\n        //------------------------------------------\n        MODIFY_NON_ASSIGNABLE_ARG_ERROR,\n        MODIFY_CONST_ARG_ERROR,\n        CHECK_ARG_MISSING_INEQUAL_OPERATOR_ERROR,\n\n        COUNT\n    };\n\n\n    //const OverrideStatus DEFAULT_STATUS = OverrideStatus::NO_OVERRIDE;\n\n    inline std::string OverrideStatusToString(OverrideStatus status)\n    {\n        static_assert((int)OverrideStatus::COUNT == 10, \"\");\n\n        switch (status)\n        {\n            case OverrideStatus::NO_OVERRIDE:\n                return \"NO_OVERRIDE\";\n            case OverrideStatus::OVERRIDE_SUCCESS:\n                return \"OVERRIDE_SUCCESS\";\n            case OverrideStatus::MATCHING_CONDITION_VALUE_FAILED:\n                return \"MATCHING_CONDITION_VALUE_FAILED\";\n            case OverrideStatus::MATCHING_CONDITION_ACTION_FAILED:\n                return \"MATCHING_CONDITION_ACTION_FAILED\";\n            case OverrideStatus::MATCHING_OVERRIDE_TIMES_FAILED:\n                return \"MATCHING_OVERRIDE_TIMES_FAILED\";\n            case OverrideStatus::RETURN_ACTION_TYPE_MISMATCH:\n                return \"RETURN_ACTION_TYPE_MISMATCH\";\n            case OverrideStatus::INTERNAL_MISSING_CHECK_ERROR:\n                return \"INTERNAL_MISSING_CHECK_ERROR\";\n            case OverrideStatus::MODIFY_NON_ASSIGNABLE_ARG_ERROR:\n                return \"MODIFY_NON_ASSIGNABLE_ARG_ERROR\";\n            case OverrideStatus::MODIFY_CONST_ARG_ERROR:\n                return \"MODIFY_CONST_ARG_ERROR\";\n            case OverrideStatus::CHECK_ARG_MISSING_INEQUAL_OPERATOR_ERROR:\n                return \"CHECK_ARG_MISSING_INEQUAL_OPERATOR_ERROR\";\n            case OverrideStatus::COUNT:\n                return \"COUNT\";\n            default:\n                return \"UNKNOWN\";\n        }\n    }\n\n}\n\n\n\n#endif\n</code></pre> <p></p>"},{"location":"inspect_overrides/#get-override-results-for-a-specific-function","title":"Get Override Results For A Specific Function","text":"<p>Use <code>CO_GET_OVERRIDE_RESULTS</code> to get detailed result information for a specific function:</p> <pre><code>std::vector&lt;CppOverride::ResultPtr&gt; results = CO_GET_OVERRIDE_RESULTS(overrideInstance, functionName);\n</code></pre> <p>This returns a vector of <code>ResultPtr</code> objects (one for each override instruction for that function)  containing detailed status information.</p> <p>Note</p> <p>If you have multiple overrides for the same function, the results will be returned in the order  you set up the instructs for the overrides.</p> Example <pre><code>CO_DECLARE_INSTANCE(MyOverrideInstance);\n\n//Set up multiple overrides for the same function\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .WhenCalledWith(1)\n               .Returns&lt;int&gt;(100)\n               .Expected();\n\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .WhenCalledWith(2)\n               .Returns&lt;int&gt;(200)\n               .Expected();\n\n//Run your code\nMyFunction(1);\nMyFunction(3);  //This won't match any override\n\n//Get detailed results\nstd::vector&lt;CppOverride::ResultPtr&gt; results = \n    CO_GET_OVERRIDE_RESULTS(MyOverrideInstance, \"MyFunction\");\n\nfor(size_t i = 0; i &lt; results.size(); ++i)\n{\n    if(results[i])\n    {\n        std::cout &lt;&lt; \"Override \" &lt;&lt; i &lt;&lt; \":\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"  Success count: \" &lt;&lt; results[i]-&gt;GetSucceedCount() &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"  Failed count: \" &lt;&lt; results[i]-&gt;GetFailedCount() &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"  Last status: \" &lt;&lt; \n            CppOverride::OverrideStatusToString(results[i]-&gt;GetLastStatus()) &lt;&lt; std::endl;\n    }\n}\n</code></pre>"},{"location":"instruct_overrides/","title":"3. Instruct Overrides","text":"<p>After inserting the override implementations, you can instruct the override instance to control  what the override functions do when called.</p>"},{"location":"instruct_overrides/#instructing-referenceable-function","title":"Instructing Referenceable Function","text":"<pre><code>CO_INSTRUCT_REF(overrideInstance, scope, functionName)\n               .Action1(...)\n               .Action2(...);\n</code></pre> <p><code>CO_GLOBAL</code> can be used as <code>scope</code> when you are trying to instruct global function.</p> <p>All the actions are defined in <code>OverrideInfoSetter</code> for normal overrides and  <code>OverridePassthroughInfoSetter</code> for passthrough. The detail for each action is covered later in this  documentation.</p> Example <pre><code>//int FreeFunction(int value1, float value2)\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, FreeFunction)\n               .Returns&lt;int&gt;(42);\n\n//template&lt;typename T&gt;\n//int FreeTemplateFunction(T value1)\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, FreeTemplateFunction&lt;int&gt;)\n               .Returns&lt;int&gt;(42);\n\n//int MyClass::MemberFunction(int value1, float value2);\nCO_INSTRUCT_REF(MyOverrideInstance, MyClass, MemberFunction)\n               .Returns&lt;int&gt;(42);\n\n//template&lt;typename T&gt;\n//int MyTemplateClass&lt;T&gt;::AnotherMemberFunction(int value1, float value2);\nCO_INSTRUCT_REF(MyOverrideInstance, MyTemplateClass&lt;int&gt;, AnotherMemberFunction)\n               .Returns&lt;int&gt;(42);\n</code></pre> <p>Important</p> <p>Here are the things we look at when selecting which override instruction to use:</p> <ul> <li>Function name (<code>__func__</code>)</li> <li>Argument Types</li> <li>Return Types</li> <li>Additional action requirement such as <code>If</code>, <code>WhenCalledWith</code>, etc.</li> </ul> <p>Important</p> <p>The <code>scope</code> is only used for referencing the function so that it verify if the function exists or not, as well as allowing renaming for LSP. It is NOT used for filtering override  functions.</p> <p></p>"},{"location":"instruct_overrides/#instructing-non-referenceable-function","title":"Instructing Non Referenceable Function","text":"<p>There is a limitation to this where some type of functions cannot be reference with <code>CO_INSTRUCT_REF</code>. In this case, you will need to use <code>CO_INSTRUCT_NO_REF</code> variant.</p> <pre><code>CO_INSTRUCT_NO_REF(overrideInstance, functionName)\n                  .Action1(...)\n                  .Action2(...);\n</code></pre> <p>You should use this macro variant for:</p> <ul> <li>Unreferencable function, such as ones in anonymous namespace or not included in the file which  performs <code>CO_INSTRUCT</code></li> <li>Overloaded functions</li> <li>Constructor, Destructor</li> <li>Complexly declared function</li> </ul> <p>If you encountered one that you think it should work with <code>CO_INSTRUCT_REF</code>, please let us know.</p> <p></p>"},{"location":"instruct_overrides/#instructing-passthrough","title":"Instructing Passthrough","text":"<p>Functions without explicit instructions are called passthrough, and is recorded everytime when it  happens. Only a limited subset of actions are allowed for passthrough but it works the same as  the normal <code>CO_INSTRUCT</code> macros.</p> <pre><code>CO_INSTRUCT_PASSTHROUGH(overrideInstance)\n                       .Action1(...)\n                       .Action2(...);\n</code></pre> <p></p>"},{"location":"instruct_overrides/#removing-instructs","title":"Removing Instructs","text":"<p>Here are the macros for removing instructs.</p> <pre><code>CO_REMOVE_INSTRUCT_REF(overrideInstance, scope, functionName);\nCO_REMOVE_INSTRUCT_NO_REF(overrideInstance, functionName);\nCO_REMOVE_INSTRUCT_PASSTHROUGH(overrideInstance);\nCO_CLEAR_ALL_INSTRUCTS(overrideInstance);\n</code></pre> <p></p>"},{"location":"instruct_overrides/#action-chaining","title":"Action Chaining","text":"<p>Actions can be chained together in any order:</p> <pre><code>CO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .WhenCalledWith(42, 3.14f)\n               .SetArgs&lt;CO_ANY_TYPE, float&amp;&gt;(CO_DONT_SET, 2.71f)\n               .Returns&lt;int&gt;(100)\n               .Times(2)\n               .Expected();\n</code></pre>"},{"location":"instruct_overrides/#actions-returns","title":"Actions: Returns","text":""},{"location":"instruct_overrides/#returns-a-specific-value-returns","title":"Returns a specific value (<code>Returns</code>):","text":"<pre><code>.Returns&lt;ReturnType&gt;(value)\n</code></pre>"},{"location":"instruct_overrides/#returns-void-early-return-returnsvoid","title":"Returns void (early return) (<code>ReturnsVoid</code>):","text":"<pre><code>.Returns&lt;void&gt;()\n//or\n.ReturnsVoid()\n</code></pre>"},{"location":"instruct_overrides/#returns-using-a-function-returnsbyaction","title":"Returns using a function (<code>ReturnsByAction</code>):","text":"<pre><code>.ReturnsByAction&lt;ReturnType&gt;(std::function&lt;TypedDataInfo(void* instance, \n                                                         const std::vector&lt;TypedDataInfo&gt;&amp; args, \n                                                         cosnt TypedInfo&amp; returnInfo)&gt;)\n</code></pre> <code>TypedDataInfo.hpp</code> <pre><code>#ifndef CO_TYPED_DATA_INFO_HPP\n#define CO_TYPED_DATA_INFO_HPP\n\n#include \"PureType.hpp\"\n\n#include &lt;typeinfo&gt;\n#include &lt;cstddef&gt;\n#include &lt;memory&gt;\n\nnamespace CppOverride\n{\n    struct TypedDataInfo\n    {\n        std::shared_ptr&lt;void&gt; ManagedData = nullptr;\n        void* UnmanagedData = nullptr;\n        std::size_t TypeHash = 0;\n        bool IsSet = false;\n        bool Managed = false;\n\n        template&lt;typename T&gt;\n        inline TypedDataInfo&amp; CreateReference(INTERNAL_CO_UNREF(T)* dataPtr)\n        {\n            UnmanagedData = dataPtr;\n            TypeHash = typeid(T).hash_code();\n            IsSet = dataPtr != nullptr;\n            Managed = false;\n            return *this;\n        }\n\n        template&lt;typename T&gt;\n        inline TypedDataInfo&amp; CreateValue(T data)\n        {\n            ManagedData = std::shared_ptr&lt;void&gt;(new INTERNAL_CO_UNREF(T)(data));\n            TypeHash = typeid(T).hash_code();\n            IsSet = true;\n            Managed = true;\n            return *this;\n        }\n\n        template&lt;typename T&gt;\n        inline INTERNAL_CO_UNREF(T)* GetTypedDataPtr() const\n        {\n            return static_cast&lt;INTERNAL_CO_UNREF(T)*&gt;(Managed ? ManagedData.get() : UnmanagedData);\n        }\n\n        template&lt;typename T&gt;\n        inline bool IsType() const\n        {\n            return IsSet &amp;&amp; (TypeHash == typeid(T).hash_code());\n        }\n    };\n}\n\n#endif \n</code></pre> <code>TypedInfo.hpp</code> <pre><code>#ifndef CO_TYPED_INFO_HPP\n#define CO_TYPED_INFO_HPP\n\n#include &lt;typeinfo&gt;\n#include &lt;cstddef&gt;\n\nnamespace CppOverride\n{\n    struct TypedInfo\n    {\n        std::size_t TypeHash = 0;\n        bool IsSet = false;\n\n        template&lt;typename T&gt;\n        inline TypedInfo&amp; Create()\n        {\n            TypeHash = typeid(T).hash_code();\n            IsSet = true;\n            return *this;\n        }\n\n        template&lt;typename T&gt;\n        inline bool IsType() const\n        {\n            return IsSet &amp;&amp; (TypeHash == typeid(T).hash_code());\n        }\n    };\n}\n\n#endif \n</code></pre> Example <pre><code>//Return a specific value\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .Returns&lt;int&gt;(42);\n\n//Return void early\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyVoidFunction)\n               .ReturnsVoid();\n\n//Return using lambda\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .ReturnsByAction&lt;int&gt;\n               (\n                   [](void* instance, \n                      const std::vector&lt;TypedDataInfo&gt;&amp; args, \n                      const TypedInfo&amp; returnInfo) -&gt; TypedDataInfo\n                   {\n                       //NOTE: instance can be nullptr if it is a free function\n                       if(returnInfo.IsType&lt;int&gt;())\n                           return TypeDataInfo().CreateValue&lt;int&gt;(100);\n\n                        return TypeDataInfo();\n                   }\n               });\n\n//Return a reference using lambda\nint returnValue = 0;\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .ReturnsByAction&lt;int&amp;&gt;\n               (\n                   [&amp;returnValue](void* instance, \n                                  const std::vector&lt;TypedDataInfo&gt;&amp; args, \n                                  const TypedInfo&amp; returnInfo) -&gt; TypedDataInfo\n                   {\n                       if(returnInfo.IsType&lt;int&amp;&gt;())\n                           return TypeDataInfo().CreateReference&lt;int&amp;&gt;(&amp;returnValue);\n\n                        return TypeDataInfo();\n                   }\n               });\n</code></pre>"},{"location":"instruct_overrides/#actions-arguments","title":"Actions: Arguments","text":""},{"location":"instruct_overrides/#set-specific-argument-values-setargs","title":"Set specific argument values (<code>SetArgs</code>):","text":"<pre><code>.SetArgs&lt;ArgType1, ArgType2, ...&gt;(value1, value2, ...)\n</code></pre>"},{"location":"instruct_overrides/#set-arguments-using-a-function-setargsbyaction","title":"Set arguments using a function (<code>SetArgsByAction</code>):","text":"<pre><code>.SetArgsByAction&lt;ArgType1, ArgType2, ...&gt;(std::function&lt;void(void* instance, \n                                                             std::vector&lt;TypedDataInfo&gt;&amp; args)&gt;)\n</code></pre> <p><code>instance</code> can be <code>nullptr</code> if it is a free function.</p> <p>Use <code>CO_ANY_TYPE</code> and <code>CO_DONT_SET</code> to skip certain arguments.</p> Example <pre><code>//Set specific values\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .SetArgs&lt;int, float&amp;&gt;(42, 3.14f);\n\n//Skip first argument, set second\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .SetArgs&lt;CO_ANY_TYPE, float&amp;&gt;(CO_DONT_SET, 3.14f);\n\n//Set using lambda\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .SetArgsByAction&lt;int, float&amp;&gt;\n               (\n                   [](void* instance, std::vector&lt;TypedDataInfo&gt;&amp; args) \n                   {\n                       //NOTE: instance can be nullptr if it is a free function\n                       (void)instance;\n\n                       if(args[0].IsType&lt;int&gt;())\n                           *args[0].GetTypedDataPtr&lt;int&gt;() = 42;\n                       if(args[1].IsType&lt;float&amp;&gt;())\n                           *args[1].GetTypedDataPtr&lt;float&amp;&gt;() = 3.14f;\n                   }\n               );\n</code></pre> <p></p>"},{"location":"instruct_overrides/#actions-conditions","title":"Actions: Conditions","text":""},{"location":"instruct_overrides/#match-specific-argument-values-whencalledwith","title":"Match specific argument values (<code>WhenCalledWith</code>):","text":"<pre><code>.WhenCalledWith(value1, value2, ...)\n</code></pre>"},{"location":"instruct_overrides/#custom-condition-using-function-if","title":"Custom condition using function (<code>If</code>):","text":"<pre><code>.If(std::function&lt;bool(void* instance, const std::vector&lt;TypedDataInfo&gt;&amp; args)&gt;)\n</code></pre> <p>Use <code>CO_ANY</code> to match any value for specific arguments.</p> Example <pre><code>//Match specific values\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .WhenCalledWith(42, 3.14f)\n               .Returns&lt;int&gt;(100);\n\n//Match any value for second argument\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .WhenCalledWith(42, CO_ANY)\n               .Returns&lt;int&gt;(100);\n\n//Custom condition\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .If\n               (\n                   [](void* instance, const std::vector&lt;TypedDataInfo&gt;&amp; args) \n                   {\n                       //NOTE: instance can be nullptr if it is a free function\n                       (void)instance;\n\n                       return args[0].IsType&lt;int&gt;() &amp;&amp; *args[0].GetTypedDataPtr&lt;int&gt;() &gt; 10;\n                   }\n               )\n               .Returns&lt;int&gt;(100);\n</code></pre> <p></p>"},{"location":"instruct_overrides/#actions-controls","title":"Actions: Controls","text":""},{"location":"instruct_overrides/#limit-number-of-times-override-is-triggered-times","title":"Limit number of times override is triggered (<code>Times</code>):","text":"<pre><code>.Times(count)\n</code></pre>"},{"location":"instruct_overrides/#match-specific-object-instance-for-member-functions-matchesobject","title":"Match specific object instance (for member functions) (<code>MatchesObject</code>):","text":"<pre><code>.MatchesObject(&amp;objectInstance)\n</code></pre>"},{"location":"instruct_overrides/#match-any-object-instance-matchesany","title":"Match any object instance (<code>MatchesAny</code>):","text":"<pre><code>.MatchesAny()\n</code></pre> Example <pre><code>//Trigger only once\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .Times(1)\n               .Returns&lt;int&gt;(42);\n\n//Match specific object\nMyClass obj;\nCO_INSTRUCT_REF(MyOverrideInstance, MyClass, MemberFunction)\n               .MatchesObject(&amp;obj)\n               .Returns&lt;int&gt;(42);\n</code></pre>"},{"location":"instruct_overrides/#actions-callbacks","title":"Actions: Callbacks","text":""},{"location":"instruct_overrides/#execute-code-when-override-is-triggered-whencalledexpectedly_do","title":"Execute code when override is triggered (<code>WhenCalledExpectedly_Do</code>):","text":"<pre><code>.WhenCalledExpectedly_Do(std::function&lt;void(void* instance, std::vector&lt;TypedDataInfo&gt;&amp; args)&gt;)\n</code></pre>"},{"location":"instruct_overrides/#execute-code-when-override-is-not-triggered-otherwise_do","title":"Execute code when override is NOT triggered (<code>Otherwise_Do</code>):","text":"<p>An override can fail to trigger due to override conditions not met or having error while overriding.</p> <p>See 4. Inspect Override Expectations on getting details regarding the failure of triggering override.</p> <pre><code>.Otherwise_Do(std::function&lt;void(void* instance, std::vector&lt;TypedDataInfo&gt;&amp; args)&gt;)\n</code></pre> Example <pre><code>bool wasCalled = false;\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .WhenCalledWith(42)\n               .Returns&lt;int&gt;(100)\n               .WhenCalledExpectedly_Do\n               (\n                   [&amp;wasCalled](void*, std::vector&lt;TypedDataInfo&gt;&amp;) \n                   {\n                       wasCalled = true;\n                   }\n               )\n               .Otherwise_Do\n               (\n                   [](void*, std::vector&lt;TypedDataInfo&gt;&amp;) \n                   {\n                       std::cout &lt;&lt; \"Override condition not met!\" &lt;&lt; std::endl;\n                   }\n               );\n</code></pre> <p></p>"},{"location":"instruct_overrides/#actions-expectations-and-results","title":"Actions: Expectations And Results","text":""},{"location":"instruct_overrides/#mark-override-as-expected-to-satisfy-all-conditions-expected","title":"Mark override as expected to satisfy all conditions (<code>Expected</code>):","text":"<pre><code>.Expected()\n</code></pre> <p>Note</p> <p>This means that if there's a <code>Times(count)</code> condition, the override will be expected to be  triggered exactly <code>count</code> times. Otherwise, the override will be expected to be triggered at  least once.</p> <p></p>"},{"location":"instruct_overrides/#mark-override-as-expected-not-to-satisfy-all-conditions-expectednotsatisfied","title":"Mark override as expected NOT to satisfy all conditions (<code>ExpectedNotSatisfied</code>):","text":"<pre><code>ExpectedNotSatisfied()\n</code></pre> <p>Warning</p> <p><code>Expected</code> and ExpectedNotSatisfied` are mutually exclusive. Only one of them is true. </p> <p>So if you have <code>Times(count)</code> condition, ExpectedNotSatisfied<code>will be true if the override is  triggered not **EXACTLY**</code>count` times.</p> <p></p>"},{"location":"instruct_overrides/#get-override-result-assignsresult","title":"Get override result (<code>AssignsResult</code>):","text":"<pre><code>CppOverride::ResultPtr result; //using ResultPtr = std::shared_ptr&lt;OverrideResult&gt;;\n.AssignsResult(result)\n</code></pre> <p>For more information about <code>CppOverride::ResultPtr</code>, see Override Result section.</p> Example <pre><code>CppOverride::ResultPtr result;\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .WhenCalledWith(42)\n               .Returns&lt;int&gt;(100)\n               .AssignsResult(result)\n               .Expected();\n\nMyFunction(42);  //Should succeed\nassert(result-&gt;LastStatusSucceed());\n\nMyFunction(99);  //Should fail condition\nassert(result-&gt;GetLastStatus() == CppOverride::OverrideStatus::MATCHING_CONDITION_VALUE_FAILED);\n</code></pre> <p></p>"},{"location":"instruct_overrides/#passthrough-actions","title":"Passthrough Actions","text":"<p>For <code>CO_INSTRUCT_PASSTHROUGH</code>, only a subset of actions are available:</p> <pre><code>CO_INSTRUCT_PASSTHROUGH(overrideInstance)\n                       .Times(count)\n                       .Expected()\n                       .ExpectedNotSatisfy();\n</code></pre> <p></p>"},{"location":"mock_class_generator/","title":"Mock Class Generator","text":"<p>Unlike other mocking frameworks, we ship with a mock class generator that is built along with the project that parses a given header and output the equivalent mock class header.</p> <p>Do keep in mind that this is just a rough header parser so manual adjustment might still be needed. For more details, do <code>GenerateMockClass --help</code>.</p> <p>To write the output to a file on Unix do</p> <pre><code>./GenerateMockClass &lt;options...&gt; &lt;input header&gt; &gt; ./MyMockClass.hpp\n</code></pre> <p>or in Windows Powershell</p> <pre><code>./GenerateMockClass &lt;options...&gt; &lt;input header&gt; | Set-Content -Encoding UTF8NoBOM ./MyMockClass.hpp\n</code></pre>"},{"location":"override_external/","title":"Overriding External Symbols","text":"<p>It is very difficult to override external functions or objects since unlike other languages like C#, everything is compiled and there's no way to change the behavior of it.</p> <p>In order to override an external function or objects,  we first need to create an override version of it.</p> <p>Let's say we have the following external class and function.</p> <pre><code>//External Class, cannot edit this\nclass FileWriter\n{\n    public:\n        bool CreateFile(std::string fileName);\n        bool WriteContent(const std::string&amp; content);\n        bool Close();\n};\n\n//External Function, cannot edit this\nFileWriter GetDatabaseInternalWriter(std::string tableName);\n</code></pre> <p>We should create the corresponding override versions of them. </p> <pre><code>extern CO_DECLARE_INSTANCE(MyOverrideInstance);\n\nclass MockFileWritter\n{\n    public:\n        CO_INSERT_MEMBER_METHOD(MyOverrideInstance, bool, CreateFile, (std::string));\n        CO_INSERT_MEMBER_METHOD(MyOverrideInstance, bool, WriteContent, (std::string));\n        CO_INSERT_MEMBER_METHOD(MyOverrideInstance, bool, Close, ());\n}\n\nCO_INSERT_METHOD(MyOverrideInstance, MockFileWritter, MockGetDatabaseInternalWriter, (std::string));\n</code></pre> <p>Let's say we have a piece of code like this in our codebase</p> <pre><code>bool WriteToDatabaseRecord(int key, const std::string&amp; data)\n{\n    FileWriter databaseWriter = GetDatabaseInternalWriter(\"UserData\");\n    if(!databaseWriter.WriteContent(std::to_string(key) + \",\" + data))\n        return false;\n\n    ...\n\n    return databaseWriter.Close();\n}\n</code></pre> <p>As you can see, we don't even hold a reference to <code>databaseWriter</code> outside of this function, let alone overriding and testing it. </p> <p>That's why it is recommended to declare the override instance in global scope. So that you can override the behavior of objects that you cannot reference in test.</p> <p>In order to override it, we would have to make some changes to this code unfortunately.</p> <p>While people would normally suggest rewriting the code using template or interface,  this normally requires a lot of rewriting and restructure to the codebase.</p> <p>Instead, we can just use the powerful (yet dangerous) preprocessing system.</p> <p>Without rewriting and restructuring, we can just</p> <pre><code>#if !defined(CO_NO_OVERRIDE) || !CO_NO_OVERRIDE\n    #define GetDatabaseInternalWriter MockGetDatabaseInternalWriter\n    #define FileWritter MockFileWritter\n#endif\n</code></pre> <p>This way, the original code is modified when testing while being untouched.</p> <p>This is what it will look like after the macro replacement.</p> <pre><code>bool WriteToDatabaseRecord(int key, const std::string&amp; data)\n{\n    MockFileWritter databaseWriter = MockGetDatabaseInternalWriter(\"UserData\");\n    if(!databaseWriter.WriteContent(std::to_string(key) + \",\" + data))\n        return false;\n\n    ...\n\n    return databaseWriter.Close();\n}\n</code></pre>"}]}