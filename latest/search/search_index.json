{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Cpp Override is a C++ 11 Framework that allows you to override function behaviors. </p> <p>This allows testing in a per function basis instead of being forced to use classes,  though you can still use this framework to perform mocking in the traditional OOP way.</p> <p>We even ship with a mock class generator which parses a given header and gives back mock class you can use.</p> <p>Using the framework is very simple, after you declare an override instance, you just need to follow the \"Insert, Instruct, Inspect\" steps to setup and test your overridden functions.</p> <p>\ud83d\ude80 Features</p> <ul> <li>\u2699\ufe0f Override any classes you want, including non virtual classes</li> <li>\ud83d\udca1 Override any functions you want, including free functions</li> <li>\ud83d\udcd1 Doesn't break C++ Standard, no need to exploit vtable</li> <li>\ud83d\udd0c Easy to setup and use</li> <li>\ud83d\udd0b Batteries included, generate mock classes using the mock class generator</li> </ul>"},{"location":"getting_started/","title":"1. Getting Started","text":""},{"location":"getting_started/#1-installation","title":"1. Installation","text":"<p>Cpp Override is hosted on github at  https://github.com/Neko-Box-Coder/CppOverride.  Feel free to check out the source code yourself.</p> <p>To start off, you first need to clone (git submodule) the repository to a location of your choice. <pre><code># Submodule\ngit submodule add https://github.com/Neko-Box-Coder/CppOverride.git &lt;folder name&gt;\ngit submodule update --init --recursive\n\n# Cloning\ngit clone --recursive https://github.com/Neko-Box-Coder/CppOverride.git\n</code></pre></p> <p>This framework is header only so you can just include it with</p> <p><code>CppOverride.hpp</code> in <code>Include_SingleHeader</code> or <code>Include_MultiHeader</code></p> <p>Additionally, you can add the include directory with</p> <pre><code>AddSubDirectory(CppOverride)\nTargetLinkLibrary(YourTarget CppOverride)\n</code></pre>"},{"location":"getting_started/#2-override-behavior","title":"2. Override Behavior","text":"<p>CppOverride uses the \"Insert, Instruct, Inspect\" phases.</p> <p>The override works by inserting override logic at the beginning of a function. </p> <p>Then, the user can instruct how the overrides behave. The override perform \"passthrough\"  where it will do nothing and continue execution for the rest of the function if no instructs are given for that function.</p> <p>Finally, the user can inspect overrides results that do not meet the expectations.</p> <p>Since CppOverride is a macro driven framework, you can disable all macros by just defining  <code>CO_NO_OVERRIDE</code> to 1 or true. </p> <pre><code>#define CO_NO_OVERRIDE 1\n#include \"CppOverride.hpp\"\n</code></pre> <p>This way, you only need to pay for the functions you need to override  and not anything else.</p>"},{"location":"getting_started/#3-declare-override-instance","title":"3. Declare Override Instance","text":"<p>In order to override anything, we need to declare an override instance to store all the  override information that the function and test can reference from.</p>"},{"location":"getting_started/#global-file-scope-recommended","title":"Global / File Scope (Recommended)","text":"<p>Declaring it in global scope makes it easy to be accessed from both the function and the test.</p> <pre><code>CO_DECLARE_INSTANCE(OverrideObjName);\n\n//Or this if you want to reference an instance defined somewhere else\nextern CO_DECLARE_INSTANCE(OverrideObjName);\n</code></pre>"},{"location":"getting_started/#class-scope","title":"Class Scope","text":"<p>Declaring it in class scope is more similar to the traditional mock class approach</p> <p>You can do so by inheriting from <code>CppOverride::Overridable</code></p> <pre><code>class YourClass : public CppOverride::Overridable\n</code></pre> <p>In this case, you can just pass <code>*this</code> as the override instance, or the instance name you declared  for the class. </p>"},{"location":"insert_overrides/","title":"2. Insert Overrides","text":"<p>After declaring the override instance, we are now ready to override any function using override implementations macros.</p>"},{"location":"insert_overrides/#overriding-existing-methods","title":"Overriding Existing Methods","text":"<p>CppOverride works by inserting an interception macro at the beginning of a function that  intercepts the rest of the logic of a function.</p> <p>This works for any functions you control. For external functions such as ones from the standard  library, you can work around it by using macro, which we will cover later in this documentation.</p> <p>To insert an override for a free function, simply use</p> <pre><code>CO_INSERT_IMPL(overrideInstance, returnType, (argument0, argument1, ...));\n</code></pre> Example <pre><code>    extern CO_DECLARE_INSTANCE(MyOverrideInstance);\n\n    int MyFreeFunction(int arg1, char* arg2, const std::string&amp; arg3)\n    {\n        CO_INSERT_IMPL(MyOverrideInstance, int, (arg1, arg2, arg3));\n        //Rest of function logic...\n        return 0;\n    }\n</code></pre> <p>Warning</p> <p>If you have comma in your return type (such as <code>std::tuple&lt;int, int&gt;</code>), you need to add an extra parenthesis to protect it against macro.</p> <p>For example: <pre><code>//std::tuple&lt;int, int&gt; FreeFunction(std::tuple&lt;int, int&gt; value1, float value2)\nCO_INSERT_IMPL(MyOverrideInstance, (std::tuple&lt;int, int&gt;), (value1, value2));\n</code></pre></p> <p>For class member functions, there are different versions of macro depending what you want to insert  the override.</p> <p>For normal member function, it works exactly like <code>CO_INSERT_IMPL</code>, except this macro records the  address of the object as well (<code>this</code>) which you can match against during instructing the override.</p> <pre><code>CO_INSERT_MEMBER_IMPL(overrideInstance, returnType, (arg0, arg1, ...));\n</code></pre> <p>For constructor and destructor however, a different macro is needed since they don't return anything.</p> <pre><code>CO_INSERT_MEMBER_IMPL_CTOR_DTOR(overrideInstance, (arg0, arg1, ...));\n</code></pre> <p></p>"},{"location":"insert_overrides/#creating-mock-methods","title":"Creating Mock Methods","text":"<p>If you want methods that only contains the <code>CO_INSERT_*_IMPL*</code> macros, we provide corresponding  macros that create it for you so you don't have to write the whole function by hand.</p> <p>We also have a rough mock class generator which generates mock class file by parsing an existing  header that you provider, this will be covered later in this documentation.</p> <p>To create an inline free mock function implementation, an overloaded macro is provided for you which automatically inserts <code>CO_INSERT_IMPL</code> macro.</p> <pre><code>CO_INSERT_METHOD(overrideInstance, returnType, functionName, (argType0, argType1, ...))\nCO_INSERT_METHOD(overrideInstance, returnType, functionName, (argType0, argType1, ...), prepend)\nCO_INSERT_METHOD(overrideInstance, returnType, functionName, (argType0, argType1, ...), prepend, append)\nCO_INSERT_METHOD(overrideInstance, returnType, functionName, (argType0, argType1, ...), prepend, append, \n    (defaultArg0, defaultArg1, ...))\n</code></pre> <p>Warning</p> <p>If you have comma in your argument or return types (such as <code>std::tuple&lt;int, int&gt;</code>), you  need to add an extra parenthesis to protect it against macro.</p> <p>For example: <pre><code>//std::tuple&lt;int, int&gt; FreeFunction(std::tuple&lt;int, int&gt; value1, float value2)\nCO_INSERT_METHOD(MyOverrideInstance, (std::tuple&lt;int, int&gt;), FreeFunction, ((std::tuple&lt;int, int&gt;), float))\n</code></pre></p> Example <pre><code>    extern CO_DECLARE_INSTANCE(MyOverrideInstance);\n\n    CO_INSERT_METHOD(MyOverrideInstance,                             //overrideInstance\n                     int,                                            //returnType\n                     MyFreeFunction,                                 //functionName\n                     (int, char*, const std::string&amp;),               //args\n                     static,                                         //prepend\n                     noexcept,                                       //append\n                     (/* no default */, = nullptr, = \"default\"));    //defaults\n\n    //Generated function\n    static inline int MyFreeFunction(int arg1, \n                                     char* arg2 = nullptr, \n                                     const std::string&amp; arg3 = \"default\") noexcept\n    {\n        CO_INSERT_IMPL(MyOverrideInstance, int, (arg1, arg2, arg3));\n        return int();\n    }\n</code></pre> <p>For member constructor and desturctor functions, there's <code>CO_INSERT_MEMBER_METHOD_CTOR</code> and  <code>CO_INSERT_MEMBER_METHOD_DTOR</code> which automatically inserts <code>CO_INSERT_MEMBER_IMPL_CTOR_DTOR</code> macro.</p> <p>Similar to <code>CO_OVERRIDE_METHOD</code>, it is overloaded with the same arguments.</p> <pre><code>CO_INSERT_MEMBER_METHOD_CTOR(overrideInstance, className, (argType0, argType1, ...))\nCO_INSERT_MEMBER_METHOD_CTOR(overrideInstance, className, (argType0, argType1, ...), prepend)\nCO_INSERT_MEMBER_METHOD_CTOR(overrideInstance, className, (argType0, argType1, ...), prepend, append)\nCO_INSERT_MEMBER_METHOD_CTOR(overrideInstance, className, (argType0, argType1, ...), prepend, append, \n    (defaultArg0, defaultArg1, ...))\n\nCO_INSERT_MEMBER_METHOD_DTOR(overrideInstance, className)\nCO_INSERT_MEMBER_METHOD_DTOR(overrideInstance, className, prepend)\nCO_INSERT_MEMBER_METHOD_DTOR(overrideInstance, className, prepend, append)\n</code></pre> Example <pre><code>    extern CO_DECLARE_INSTANCE(MyOverrideInstance);\n\n    class YourClass\n    {\n        CO_INSERT_MEMBER_METHOD_CTOR(MyOverrideInstance, YourClass, (int, float))\n        CO_INSERT_MEMBER_METHOD_DTOR(MyOverrideInstance, YourClass)\n\n        /*Generates\n        inline YourClass::YourClass(int arg1, float arg2)\n        {\n            CO_INSERT_MEMBER_IMPL_CTOR_DTOR(MyOverrideInstance, (arg1, arg2));\n        }\n\n        inline YourClass::~YourClass()\n        {\n            CO_INSERT_MEMBER_IMPL_CTOR_DTOR(MyOverrideInstance, ());\n        }\n        */\n    }\n</code></pre> <p>For inline member mock function implementation, an overloaded macro is provided which automatically inserts <code>CO_INSERT_MEMBER_IMPL</code> macro.</p> <pre><code>CO_INSERT_MEMBER_METHOD(overrideInstance, returnType, functionName, (argType0, argType1, ...))\nCO_INSERT_MEMBER_METHOD(overrideInstance, returnType, functionName, (argType0, argType1, ...), prepend)\nCO_INSERT_MEMBER_METHOD(overrideInstance, returnType, functionName, (argType0, argType1, ...), prepend, append)  \nCO_INSERT_MEMBER_METHOD(overrideInstance, returnType, functionName, (argType0, argType1, ...), prepend, append, \n    (defaultArg0, defaultArg1, ...))\n</code></pre> Example <pre><code>    extern CO_DECLARE_INSTANCE(MyOverrideInstance);\n\n    class MockMyClass : public MyClass\n    {\n        //int MemberFunction(int value1, float value2)\n        CO_INSERT_MEMBER_METHOD(MyOverrideInstance, int, MemberFunction, (int, float))\n\n        //void MemberFunction2(float&amp; value1, int* value2) const\n        CO_INSERT_MEMBER_METHOD(MyOverrideInstance, void, MemberFunction2, (float&amp;, int*), \n            /* no prepend */, const)\n\n        //virtual int MemberFunction3(int value1, float value2 = 1.f) const override\n        CO_INSERT_MEMBER_METHOD(MyOverrideInstance, int, MemberFunction3, (int, float), \n            virtual, const override, (/* no default */, = 1.f))\n    };\n</code></pre>"},{"location":"inspect_overrides/","title":"4. Inspect Override Expectations","text":"<p>After finish running the overrided functions, you can inspect what functions did not meet the expectations you set during the instruct phase.</p> <p></p>"},{"location":"inspect_overrides/#check-failed-expectations","title":"Check Failed Expectations","text":"<p>Use <code>CO_GET_FAILED_EXPECTS</code> to get a list of functions that failed to meet their expectations:</p> <pre><code>std::vector&lt;std::string&gt; failedFunctions = CO_GET_FAILED_EXPECTS(overrideInstance);\n</code></pre> <p>This returns a vector of function names (as strings) that - Failed the <code>.Expected()</code> checks - Failed the <code>.ExpectedNotSatisfy()</code> checks</p> <p>In addition to that, if passthrough doesn't meet the expectation but cannot contribute to any  specific function (Say must passthrough 5 times, but only passthrough 3 times), then the string <code>\"Passthrough\"</code> will be added to the vector. Otherwise, the string <code>\"(Passthrough)\"</code> will be  appended to the functions that contributes to the failure of the expectation.</p> Example <pre><code>CO_DECLARE_INSTANCE(MyOverrideInstance);\n\n//Set up expectations\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .WhenCalledWith(42)\n               .Returns&lt;int&gt;(100)\n               .Times(2)\n               .Expected();\n\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, AnotherFunction)\n               .Returns&lt;void&gt;()\n               .ExpectedNotSatisfy();\n\n//Run your code\nMyFunction(42);        //Called once, but expected twice\nAnotherFunction();     //Called, but expected not to be called\n\n//Check for failed expectations\nstd::vector&lt;std::string&gt; failed = CO_GET_FAILED_EXPECTS(MyOverrideInstance);\n\nif(!failed.empty())\n{\n    std::cout &lt;&lt; \"Failed expectations:\" &lt;&lt; std::endl;\n    for(const std::string&amp; funcName : failed)\n    {\n        std::cout &lt;&lt; \"- \" &lt;&lt; funcName &lt;&lt; std::endl;\n    }\n}\n</code></pre> <p></p>"},{"location":"inspect_overrides/#debug-override-logs","title":"Debug Override Logs","text":"<p>If for any reason, it is unclear why the override did not get triggered and the override result did not give any useful information. You can force CppOverride to output verbose logs by defining <code>CO_SHOW_OVERRIDE_LOG 1</code> before <code>#include \"CppOverride.hpp\"</code>. </p> <p>This will show all the debug logs on each stage of selecting override data and what conditions  are not met.</p> <p></p>"},{"location":"inspect_overrides/#override-result","title":"Override Result","text":"<p><code>CppOverride::ResultPtr</code> is just a shared_ptr defined as this </p> <pre><code>using ResultPtr = std::shared_ptr&lt;OverrideResult&gt;;\n</code></pre> <p>Each time when there's an override attempt (whether successful or not),  it will add to the list of override status.</p> <p>To get the list of status: <pre><code>std::vector&lt;OverrideStatus&gt; statuses = result.GetAllStatuses();\n</code></pre></p> List of possible status <pre><code>enum class OverrideStatus\n{\n    //Default status.\n    // Any matching override will modify the status to not be this value.\n    // If the status is not modified (i.e. staying in this value), \n    // Could be one of these reasons:\n    // - Function name not matching\n    // - Argument types not matching\n    // - Return type not matching\n    NO_OVERRIDE,\n\n    //The last override was successful. \n    // Please reset the status to NO_OVERRIDE before every expected override. \n    // If the status is not reset, it will not be modified if no matching override is found.\n    OVERRIDE_SUCCESS,\n\n    MATCHING_CONDITION_VALUE_FAILED,\n    MATCHING_CONDITION_ACTION_FAILED,\n    MATCHING_OVERRIDE_TIMES_FAILED,\n\n    //------------------------------------------\n    //Internal error\n    //------------------------------------------\n    INTERNAL_MISSING_CHECK_ERROR,\n\n    //------------------------------------------\n    //Unsupported operation errors\n    //------------------------------------------\n    MODIFY_NON_ASSIGNABLE_ARG_ERROR,\n    MODIFY_CONST_ARG_ERROR,\n    CHECK_ARG_MISSING_INEQUAL_OPERATOR_ERROR,\n};\n</code></pre> <p>Here are a list of helper functions to perform the most common actions: <pre><code>class OverrideResult\n{\n    //Returns true if status list is not empty and last one is OVERRIDE_SUCCESS\n    bool LastStatusSucceed();\n\n    //Returns true if status list is not empty and last one is **NOT** OVERRIDE_SUCCESS\n    bool LastStatusFailed();\n\n    //Returns the last status if the status list is not empty, otherwise NO_OVERRIDE\n    OverrideStatus GetLastStatus();\n\n    //Returns true if the status list contains said status\n    bool HasStatus(OverrideStatus status);\n\n    //Returns the number of status in the status list\n    int GetStatusCount();\n\n    //Returns the number of statuses that are OVERRIDE_SUCCESS\n    int GetSucceedCount();\n\n    //Returns the number of statuses that are **NOT** OVERRIDE_SUCCESS\n    int GetFailedCount();\n\n    //Removes all the status from the status list\n    void ClearStatuses()\n\n    //Get a copy of the status list\n    std::vector&lt;OverrideStatus&gt; GetAllStatuses()\n};\n</code></pre></p> <p></p>"},{"location":"inspect_overrides/#get-override-results-for-a-specific-function","title":"Get Override Results For A Specific Function","text":"<p>Use <code>CO_GET_OVERRIDE_RESULTS</code> to get detailed result information for a specific function:</p> <pre><code>std::vector&lt;CppOverride::ResultPtr&gt; results = CO_GET_OVERRIDE_RESULTS(overrideInstance, functionName);\n</code></pre> <p>This returns a vector of <code>ResultPtr</code> objects (one for each override instruction for that function)  containing detailed status information.</p> <p>Note</p> <p>If you have multiple overrides for the same function, the results will be returned in the order  you set up the instructs for the overrides.</p> Example <pre><code>CO_DECLARE_INSTANCE(MyOverrideInstance);\n\n//Set up multiple overrides for the same function\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .WhenCalledWith(1)\n               .Returns&lt;int&gt;(100)\n               .Expected();\n\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .WhenCalledWith(2)\n               .Returns&lt;int&gt;(200)\n               .Expected();\n\n//Run your code\nMyFunction(1);\nMyFunction(3);  //This won't match any override\n\n//Get detailed results\nstd::vector&lt;CppOverride::ResultPtr&gt; results = \n    CO_GET_OVERRIDE_RESULTS(MyOverrideInstance, \"MyFunction\");\n\nfor(size_t i = 0; i &lt; results.size(); ++i)\n{\n    if(results[i])\n    {\n        std::cout &lt;&lt; \"Override \" &lt;&lt; i &lt;&lt; \":\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"  Success count: \" &lt;&lt; results[i]-&gt;GetSucceedCount() &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"  Failed count: \" &lt;&lt; results[i]-&gt;GetFailedCount() &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"  Last status: \" &lt;&lt; \n            CppOverride::OverrideStatusToString(results[i]-&gt;GetLastStatus()) &lt;&lt; std::endl;\n    }\n}\n</code></pre>"},{"location":"instruct_overrides/","title":"3. Instruct Overrides","text":"<p>After inserting the override implementations, you can instruct the override instance to control  what the override functions do when called.</p>"},{"location":"instruct_overrides/#instructing-referenceable-function","title":"Instructing Referenceable Function","text":"<pre><code>CO_INSTRUCT_REF(overrideInstance, scope, functionName)\n               .Action1(...)\n               .Action2(...);\n</code></pre> <p><code>CO_GLOBAL</code> can be used as <code>scope</code> when you are trying to instruct global function.</p> <p>All the actions are defined in <code>OverrideInfoSetter</code> for normal overrides and  <code>OverridePassthroughInfoSetter</code> for passthrough. The detail for each action is covered later in this  documentation.</p> Example <pre><code>//int FreeFunction(int value1, float value2)\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, FreeFunction)\n               .Returns&lt;int&gt;(42);\n\n//template&lt;typename T&gt;\n//int FreeTemplateFunction(T value1)\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, FreeTemplateFunction&lt;int&gt;)\n               .Returns&lt;int&gt;(42);\n\n//int MyClass::MemberFunction(int value1, float value2);\nCO_INSTRUCT_REF(MyOverrideInstance, MyClass, MemberFunction)\n               .Returns&lt;int&gt;(42);\n\n//template&lt;typename T&gt;\n//int MyTemplateClass&lt;T&gt;::AnotherMemberFunction(int value1, float value2);\nCO_INSTRUCT_REF(MyOverrideInstance, MyTemplateClass&lt;int&gt;, AnotherMemberFunction)\n               .Returns&lt;int&gt;(42);\n</code></pre> <p>Important</p> <p>Here are the things we look at when selecting which override instruction to use:</p> <ul> <li>Function name (<code>__func__</code>)</li> <li>Argument Types</li> <li>Return Types</li> <li>Additional action requirement such as <code>If</code>, <code>WhenCalledWith</code>, etc.</li> </ul> <p>Important</p> <p>The <code>scope</code> is only used for referencing the function so that it verify if the function exists or not, as well as allowing renaming for LSP. It is NOT used for filtering override  functions.</p> <p></p>"},{"location":"instruct_overrides/#instructing-non-referenceable-function","title":"Instructing Non Referenceable Function","text":"<p>There is a limitation to this where some type of functions cannot be reference with <code>CO_INSTRUCT_REF</code>. In this case, you will need to use <code>CO_INSTRUCT_NO_REF</code> variant.</p> <pre><code>CO_INSTRUCT_NO_REF(overrideInstance, functionName)\n                  .Action1(...)\n                  .Action2(...);\n</code></pre> <p>You should use this macro variant for:</p> <ul> <li>Unreferencable function, such as ones in anonymous namespace or not included in the file which  performs <code>CO_INSTRUCT</code></li> <li>Overloaded functions</li> <li>Constructor, Destructor</li> <li>Complexly declared function</li> </ul> <p>If you encountered one that you think it should work with <code>CO_INSTRUCT_REF</code>, please let us know.</p> <p></p>"},{"location":"instruct_overrides/#instructing-passthrough","title":"Instructing Passthrough","text":"<p>Functions without explicit instructions are called passthrough, and is recorded everytime when it  happens. Only a limited subset of actions are allowed for passthrough but it works the same as  the normal <code>CO_INSTRUCT</code> macros.</p> <pre><code>CO_INSTRUCT_PASSTHROUGH(overrideInstance)\n                       .Action1(...)\n                       .Action2(...);\n</code></pre> <p></p>"},{"location":"instruct_overrides/#removing-instructs","title":"Removing Instructs","text":"<p>Here are the macros for removing instructs.</p> <pre><code>CO_REMOVE_INSTRUCT_REF(overrideInstance, scope, functionName);\nCO_REMOVE_INSTRUCT_NO_REF(overrideInstance, functionName);\nCO_REMOVE_INSTRUCT_PASSTHROUGH(overrideInstance);\nCO_CLEAR_ALL_INSTRUCTS(overrideInstance);\n</code></pre> <p></p>"},{"location":"instruct_overrides/#actions-returns","title":"Actions: Returns","text":""},{"location":"instruct_overrides/#returns-a-specific-value","title":"Returns a specific value:","text":"<pre><code>.Returns&lt;ReturnType&gt;(value)\n</code></pre>"},{"location":"instruct_overrides/#returns-void-early-return","title":"Returns void (early return):","text":"<pre><code>.Returns&lt;void&gt;()\n//or\n.ReturnsVoid()\n</code></pre>"},{"location":"instruct_overrides/#returns-using-a-function","title":"Returns using a function:","text":"<pre><code>.ReturnsByAction&lt;ReturnType&gt;(std::function&lt;void(void* instance, \n                                                const std::vector&lt;TypedDataInfo&gt;&amp; args, \n                                                TypedDataInfo&amp; returnValue)&gt;)\n</code></pre> <p>Returning Reference With Action (Corner Case)</p> <p>When the function you overrides returns a reference, the type inside the data info will be a  pointer instead. So for example, if the return type is <code>int&amp;</code>, the type inside the data  info will be <code>int*</code>.</p> <p>So you should be using  <pre><code>returnValue.GetTypedDataPtr&lt;int*&gt;()\n</code></pre> instead of  <pre><code>returnValue.GetTypedDataPtr&lt;int&amp;&gt;()\n</code></pre></p> Example <pre><code>//Return a specific value\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .Returns&lt;int&gt;(42);\n\n//Return void early\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyVoidFunction)\n               .ReturnsVoid();\n\n//Return using lambda\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .ReturnsByAction&lt;int&gt;\n               (\n                   [](void* instance, \n                      const std::vector&lt;TypedDataInfo&gt;&amp; args, \n                      TypedDataInfo&amp; returnValue) \n                   {\n                       //NOTE: instance can be nullptr if it is a free function\n                       if(returnValue.IsType&lt;int&gt;())\n                           *returnValue.GetTypedDataPtr&lt;int&gt;() = 100;\n                   }\n               });\n\n//Return a reference using lambda\nint returnValue = 0;\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .ReturnsByAction&lt;int&amp;&gt;\n               (\n                   [&amp;returnValue](void* instance, \n                                  const std::vector&lt;TypedDataInfo&gt;&amp; args, \n                                  TypedDataInfo&amp; returnValue) \n                   {                           \n                       if(returnValue.IsType&lt;int*&gt;())\n                           *returnValue.GetTypedDataPtr&lt;int*&gt;() = &amp;returnValue;\n                   }\n               });\n</code></pre> <p></p>"},{"location":"instruct_overrides/#actions-arguments","title":"Actions: Arguments","text":""},{"location":"instruct_overrides/#set-specific-argument-values","title":"Set specific argument values:","text":"<pre><code>.SetArgs&lt;ArgType1, ArgType2, ...&gt;(value1, value2, ...)\n</code></pre>"},{"location":"instruct_overrides/#set-arguments-using-a-function","title":"Set arguments using a function:","text":"<pre><code>.SetArgsByAction&lt;ArgType1, ArgType2, ...&gt;(std::function&lt;void(void* instance, \n                                                             std::vector&lt;TypedDataInfo&gt;&amp; args)&gt;)\n</code></pre> <p><code>instance</code> can be <code>nullptr</code> if it is a free function.</p> <p>Use <code>CO_ANY_TYPE</code> and <code>CO_DONT_SET</code> to skip certain arguments.</p> Example <pre><code>//Set specific values\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .SetArgs&lt;int, float&amp;&gt;(42, 3.14f);\n\n//Skip first argument, set second\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .SetArgs&lt;CO_ANY_TYPE, float&amp;&gt;(CO_DONT_SET, 3.14f);\n\n//Set using lambda\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .SetArgsByAction&lt;int, float&amp;&gt;\n               (\n                   [](void* instance, std::vector&lt;TypedDataInfo&gt;&amp; args) \n                   {\n                       //NOTE: instance can be nullptr if it is a free function\n                       (void)instance;\n\n                       if(args[0].IsType&lt;int&gt;())\n                           *args[0].GetTypedDataPtr&lt;int&gt;() = 42;\n                       if(args[1].IsType&lt;float&amp;&gt;())\n                           *args[1].GetTypedDataPtr&lt;float&amp;&gt;() = 3.14f;\n                   }\n               );\n</code></pre> <p></p>"},{"location":"instruct_overrides/#actions-conditions","title":"Actions: Conditions","text":""},{"location":"instruct_overrides/#match-specific-argument-values","title":"Match specific argument values:","text":"<pre><code>.WhenCalledWith(value1, value2, ...)\n</code></pre>"},{"location":"instruct_overrides/#custom-condition-using-function","title":"Custom condition using function:","text":"<pre><code>.If(std::function&lt;bool(void* instance, const std::vector&lt;TypedDataInfo&gt;&amp; args)&gt;)\n</code></pre> <p>Use <code>CO_ANY</code> to match any value for specific arguments.</p> Example <pre><code>//Match specific values\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .WhenCalledWith(42, 3.14f)\n               .Returns&lt;int&gt;(100);\n\n//Match any value for second argument\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .WhenCalledWith(42, CO_ANY)\n               .Returns&lt;int&gt;(100);\n\n//Custom condition\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .If\n               (\n                   [](void* instance, const std::vector&lt;TypedDataInfo&gt;&amp; args) \n                   {\n                       //NOTE: instance can be nullptr if it is a free function\n                       (void)instance;\n\n                       return args[0].IsType&lt;int&gt;() &amp;&amp; *args[0].GetTypedDataPtr&lt;int&gt;() &gt; 10;\n                   }\n               )\n               .Returns&lt;int&gt;(100);\n</code></pre> <p></p>"},{"location":"instruct_overrides/#actions-controls","title":"Actions: Controls","text":""},{"location":"instruct_overrides/#limit-number-of-times-override-is-triggered","title":"Limit number of times override is triggered:","text":"<pre><code>.Times(count)\n</code></pre>"},{"location":"instruct_overrides/#match-specific-object-instance-for-member-functions","title":"Match specific object instance (for member functions):","text":"<pre><code>.MatchesObject(&amp;objectInstance)\n</code></pre>"},{"location":"instruct_overrides/#match-any-object-instance","title":"Match any object instance:","text":"<pre><code>.MatchesAny()\n</code></pre> Example <pre><code>//Trigger only once\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .Times(1)\n               .Returns&lt;int&gt;(42);\n\n//Match specific object\nMyClass obj;\nCO_INSTRUCT_REF(MyOverrideInstance, MyClass, MemberFunction)\n               .MatchesObject(&amp;obj)\n               .Returns&lt;int&gt;(42);\n</code></pre>"},{"location":"instruct_overrides/#actions-callbacks","title":"Actions: Callbacks","text":""},{"location":"instruct_overrides/#execute-code-when-override-is-triggered","title":"Execute code when override is triggered:","text":"<pre><code>.WhenCalledExpectedly_Do(std::function&lt;void(void* instance, const std::vector&lt;TypedDataInfo&gt;&amp; args)&gt;)\n</code></pre>"},{"location":"instruct_overrides/#execute-code-when-override-conditions-are-not-met","title":"Execute code when override conditions are NOT met:","text":"<pre><code>.Otherwise_Do(std::function&lt;void(void* instance, const std::vector&lt;TypedDataInfo&gt;&amp; args)&gt;)\n</code></pre> Example <pre><code>bool wasCalled = false;\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .WhenCalledWith(42)\n               .Returns&lt;int&gt;(100)\n               .WhenCalledExpectedly_Do(\n                   [&amp;wasCalled](void*, const std::vector&lt;TypedDataInfo&gt;&amp;) \n                   {\n                       wasCalled = true;\n                   }\n               )\n               .Otherwise_Do\n               (\n                   [](void*, const std::vector&lt;TypedDataInfo&gt;&amp;) \n                   {\n                       std::cout &lt;&lt; \"Override condition not met!\" &lt;&lt; std::endl;\n                   }\n               );\n</code></pre>"},{"location":"instruct_overrides/#actions-expectations-and-results","title":"Actions: Expectations And Results","text":""},{"location":"instruct_overrides/#mark-override-as-expected-to-satisfy-all-conditions","title":"Mark override as expected to satisfy all conditions:","text":"<pre><code>.Expected()\n</code></pre> <p>Note</p> <p>This means that if there's a <code>Times(count)</code> condition, the override will be expected to be  triggered exactly <code>count</code> times. Otherwise, the override will be expected to be triggered at  least once.</p> <p></p>"},{"location":"instruct_overrides/#mark-override-as-expected-not-to-satisfy-all-conditions","title":"Mark override as expected NOT to satisfy all conditions:","text":"<pre><code>.ExpectedNotSatisfy()\n</code></pre> <p>Warning</p> <p><code>Expected</code> and <code>ExpectedNotSatisfy</code> are mutually exclusive. Only one of them is true. </p> <p>So if you have <code>Times(count)</code> condition, <code>ExpectedNotSatisfy</code> will be true if the override is  triggered not EXACTLY <code>count</code> times.</p> <p></p>"},{"location":"instruct_overrides/#get-override-result","title":"Get override result:","text":"<pre><code>CppOverride::ResultPtr result; //using ResultPtr = std::shared_ptr&lt;OverrideResult&gt;;\n.AssignsResult(result)\n</code></pre> <p>For more information about <code>CppOverride::ResultPtr</code>, see Override Result section.</p> Example <pre><code>CppOverride::ResultPtr result;\nCO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .WhenCalledWith(42)\n               .Returns&lt;int&gt;(100)\n               .AssignsResult(result)\n               .Expected();\n\nMyFunction(42);  //Should succeed\nassert(result-&gt;LastStatusSucceed());\n\nMyFunction(99);  //Should fail condition\nassert(result-&gt;GetLastStatus() == CppOverride::OverrideStatus::MATCHING_CONDITION_VALUE_FAILED);\n</code></pre> <p></p>"},{"location":"instruct_overrides/#passthrough-actions","title":"Passthrough Actions","text":"<p>For <code>CO_INSTRUCT_PASSTHROUGH</code>, only a subset of actions are available:</p> <pre><code>CO_INSTRUCT_PASSTHROUGH(overrideInstance)\n                       .Times(count)\n                       .Expected()\n                       .ExpectedNotSatisfy();\n</code></pre> <p></p>"},{"location":"instruct_overrides/#action-chaining","title":"Action Chaining","text":"<p>Actions can be chained together in any order:</p> <pre><code>CO_INSTRUCT_REF(MyOverrideInstance, CO_GLOBAL, MyFunction)\n               .WhenCalledWith(42, 3.14f)\n               .SetArgs&lt;CO_ANY_TYPE, float&amp;&gt;(CO_DONT_SET, 2.71f)\n               .Returns&lt;int&gt;(100)\n               .Times(2)\n               .WhenCalledExpectedly_Do\n               (\n                   [](void*, const std::vector&lt;TypedDataInfo&gt;&amp;) \n                   {\n                       std::cout &lt;&lt; \"Override triggered!\" &lt;&lt; std::endl;\n                   }\n               )\n               .Expected();\n</code></pre>"},{"location":"mock_class_generator/","title":"Mock Class Generator","text":"<p>Unlike other mocking frameworks, we ship with a mock class generator that is built along with the project that parses a given header and output the equivalent mock class header.</p> <p>Do keep in mind that this is just a rough header parser so manual adjustment might still be needed. For more details, do <code>GenerateMockClass --help</code>.</p> <p>To write the output to a file on Unix do</p> <pre><code>./GenerateMockClass &lt;options...&gt; &lt;input header&gt; &gt; ./MyMockClass.hpp\n</code></pre> <p>or in Windows Powershell</p> <pre><code>./GenerateMockClass &lt;options...&gt; &lt;input header&gt; | Set-Content -Encoding UTF8NoBOM ./MyMockClass.hpp\n</code></pre>"},{"location":"override_external/","title":"Overriding External Symbols","text":"<p>It is very difficult to override external functions or objects since unlike other languages like C#, everything is compiled and there's no way to change the behavior of it.</p> <p>In order to override an external function or objects,  we first need to create an override version of it.</p> <p>Let's say we have the following external class and function.</p> <pre><code>//External Class, cannot edit this\nclass FileWriter\n{\n    public:\n        bool CreateFile(std::string fileName);\n        bool WriteContent(const std::string&amp; content);\n        bool Close();\n};\n\n//External Function, cannot edit this\nFileWriter GetDatabaseInternalWriter(std::string tableName);\n</code></pre> <p>We should create the corresponding override versions of them. </p> <pre><code>extern CO_DECLARE_INSTANCE(MyOverrideInstance);\n\nclass MockFileWritter\n{\n    public:\n        CO_INSERT_MEMBER_METHOD(MyOverrideInstance, bool, CreateFile, (std::string));\n        CO_INSERT_MEMBER_METHOD(MyOverrideInstance, bool, WriteContent, (std::string));\n        CO_INSERT_MEMBER_METHOD(MyOverrideInstance, bool, Close, ());\n}\n\nCO_INSERT_METHOD(MyOverrideInstance, MockFileWritter, MockGetDatabaseInternalWriter, (std::string));\n</code></pre> <p>Let's say we have a piece of code like this in our codebase</p> <pre><code>bool WriteToDatabaseRecord(int key, const std::string&amp; data)\n{\n    FileWriter databaseWriter = GetDatabaseInternalWriter(\"UserData\");\n    if(!databaseWriter.WriteContent(std::to_string(key) + \",\" + data))\n        return false;\n\n    ...\n\n    return databaseWriter.Close();\n}\n</code></pre> <p>As you can see, we don't even hold a reference to <code>databaseWriter</code> outside of this function, let alone overriding and testing it. </p> <p>That's why it is recommended to declare the override instance in global scope. So that you can override the behavior of objects that you cannot reference in test.</p> <p>In order to override it, we would have to make some changes to this code unfortunately.</p> <p>While people would normally suggest rewriting the code using template or interface,  this normally requires a lot of rewriting and restructure to the codebase.</p> <p>Instead, we can just use the powerful (yet dangerous) preprocessing system.</p> <p>Without rewriting and restructuring, we can just</p> <pre><code>#if !defined(CO_NO_OVERRIDE) || !CO_NO_OVERRIDE\n    #define GetDatabaseInternalWriter MockGetDatabaseInternalWriter\n    #define FileWritter MockFileWritter\n#endif\n</code></pre> <p>This way, the original code is modified when testing while being untouched.</p> <p>This is what it will look like after the macro replacement.</p> <pre><code>bool WriteToDatabaseRecord(int key, const std::string&amp; data)\n{\n    MockFileWritter databaseWriter = MockGetDatabaseInternalWriter(\"UserData\");\n    if(!databaseWriter.WriteContent(std::to_string(key) + \",\" + data))\n        return false;\n\n    ...\n\n    return databaseWriter.Close();\n}\n</code></pre>"}]}