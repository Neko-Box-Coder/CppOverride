{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cpp Override User Guide","text":"<p>Cpp Override is a C++ 11 Compatible Framework that allows you to override function behaviors. </p> <p>Similar to mocking but with greater flexibility and customizations</p>"},{"location":"#1-installation","title":"\ud83d\udce6\ufe0f 1. Installation","text":"<p>Cpp Override is hosted on github at  https://github.com/Neko-Box-Coder/CppOverride.  Feel free to check out the source code yourself.</p> <p>To start off, you first need to clone the repository with <pre><code>git submodule add https://github.com/Neko-Box-Coder/CppOverride.git &lt;folder name&gt;\ngit submodule update --init --recursive\n</code></pre> or <pre><code>git clone https://github.com/Neko-Box-Coder/CppOverride.git\n</code></pre></p> <p>This framework is header only so you can just include it with</p> <p><code>CppOverride.hpp</code> in <code>Include_SingleHeader</code> or <code>Include_MultiHeader</code></p> <p>Additionally, you can add the include directory with</p> <ul> <li><code>AddSubDirectory(CppOverride)</code></li> <li><code>TargetLinkLibrary(YourTarget CppOverride)</code></li> </ul>"},{"location":"#2-declare-override-instance","title":"\ud83d\udce2 2. Declare Override Instance","text":"<p>In order to override anything, we will first need an override instance to store all the override  information that the function and test can reference from. </p>"},{"location":"#global-file-scope","title":"Global / File Scope","text":"<p>Declaring it in global scope makes it easy to be accessed from both the function and the test.</p> <pre><code>CO_DECLARE_INSTANCE(MyOverrideInstance);\n\n//Or this if you want to reference an instance declared somewhere else\nextern CO_DECLARE_INSTANCE(MyOverrideInstance);\n</code></pre>"},{"location":"#class-scope","title":"Class Scope","text":"<p>Declaring it in class scope is more similar to the traditional mock class approach</p> <p>You can do so by inheriting from <code>CppOverride::Overridable</code></p> <pre><code>class YourClass : public CppOverride::Overridable\n{\n}\n</code></pre> <p>Or if you want to declare it manually, you can do</p> <pre><code>class YourClass\n{\n    private:\n        CO_DECLARE_MEMBER_INSTANCE(MyOverrideInstance);\n        ...\n    public:\n        CO_DECLARE_OVERRIDE_METHODS(MyOverrideInstance);\n        ...\n};\n</code></pre> <p>Tip</p> <p>Declaring override instance in Global/File scope is recommended for overriding  member functions. This is because it allows you to override constructor and destructor.  If the override information is saved inside the class,  that information is bounded to the object lifetime.</p>"},{"location":"#3-insert-override-implementations","title":"\u2699\ufe0f 3. Insert Override Implementations","text":"<p>After declaring the override instance, we are now ready to override any function using override implementations macros</p> <p>There are 2 variants of the macro, one is <code>CO_OVERRIDE_MEMBER_METHOD(...)</code> and the other one is <code>CO_OVERRIDE_METHOD(...)</code>.</p> <p>The difference between them is that the <code>CO_OVERRIDE_MEMBER_METHOD(...)</code> variant captures the  object pointer (<code>this</code>) where as the <code>CO_OVERRIDE_METHOD(...)</code> one does not.</p> <p>You can easily override a function fully with the macros below:</p> <pre><code>CO_OVERRIDE_METHOD(Override Instance, Return Type, Function Name, (Args Types))\nCO_OVERRIDE_METHOD(Override Instance, Return Type, Function Name, (Args Types), Function Prepend)\nCO_OVERRIDE_METHOD(Override Instance, Return Type, Function Name, (Args Types), Function Prepend, Function Append)\nCO_OVERRIDE_METHOD(Override Instance, Return Type, Function Name, (Args Types), Function Prepend, Function Append, (Args Defaults))\n\nCO_OVERRIDE_MEMBER_METHOD(Override Instance, Return Type, Function Name, (Args Types))\nCO_OVERRIDE_MEMBER_METHOD(Override Instance, Return Type, Function Name, (Args Types), Function Prepend)\nCO_OVERRIDE_MEMBER_METHOD(Override Instance, Return Type, Function Name, (Args Types), Function Prepend, Function Append)\nCO_OVERRIDE_MEMBER_METHOD(Override Instance, Return Type, Function Name, (Args Types), Function Prepend, Function Append, (Args Defaults))\n</code></pre> <p>Macro Arguments:</p> <ul> <li><code>Override Instance</code>: The override instance to get the override data from.  When inheriting <code>CppOverride::Overridable</code>, you can just pass <code>*this</code>.</li> <li><code>Return Type</code>: The return type of the function we are overriding</li> <li><code>Function Name</code>: The name of the function we are overriding</li> <li><code>(Args Types)</code>: List of arguments types wrapped in <code>()</code> separated by comma (<code>,</code>) to this function.</li> <li><code>Function Prepend</code> (Optional): Prepend tokens to the function</li> <li><code>Function Append</code> (Optional): Append tokens to the function</li> <li><code>(Args Defaults)</code> (Optional): List of arguments defaults wrapped in <code>()</code> separated by  comma (<code>,</code>) to this function. The syntax is just anything after the argument name. For example an argument <code>int arg = 2</code> would be <code>= 2</code>. Nothing need to be put in for the arguments that do not have defaults.  The Number of commas here MUST match the commas in <code>(Args Types)</code>.</li> </ul> Example <pre><code>CO_DECLARE_INSTANCE(MyOverrideInstance);\n\nclass MockMyClass : public MyClass\n{\n    //int MemberFunction(int value1, float value2)\n    CO_OVERRIDE_MEMBER_METHOD(MyOverrideInstance, int, MemberFunction, (int, float))\n\n    //void MemberFunction2(float&amp; value1, int* value2) const\n    CO_OVERRIDE_MEMBER_METHOD(MyOverrideInstance, void, MemberFunction2, (float&amp;, int*), \n        /* no prepend */, const)\n\n    //virtual int MemberFunction3(int value1, float value2 = 1.f) const override\n    CO_OVERRIDE_MEMBER_METHOD(MyOverrideInstance, int, MemberFunction3, (int, float), \n        virtual, const override, (/* no default */, = 1.f))\n};\n\n//MockMyClass CloneMockClass(const MockMyClass&amp; other);\nCO_OVERRIDE_METHOD(MyOverrideInstance, MockMyClass, CloneMockClass, (const MockMyClass&amp;));\n</code></pre> <p>For overriding constructor and destructor, a special macro is needed because they don't return anything, not even <code>void</code>.</p> <pre><code>CO_OVERRIDE_MEMBER_METHOD_CTOR(Override Instance, Class Name, (Args Types))\nCO_OVERRIDE_MEMBER_METHOD_CTOR(Override Instance, Class Name, (Args Types), Function Prepend)\nCO_OVERRIDE_MEMBER_METHOD_CTOR(Override Instance, Class Name, (Args Types), Function Prepend, Function Append)\nCO_OVERRIDE_MEMBER_METHOD_CTOR(Override Instance, Class Name, (Args Types), Function Prepend, Function Append, (Args Defaults))\n\nCO_OVERRIDE_MEMBER_METHOD_DTOR(Override Instance, Class Name)\nCO_OVERRIDE_MEMBER_METHOD_DTOR(Override Instance, Class Name, Function Prepend)\nCO_OVERRIDE_MEMBER_METHOD_DTOR(Override Instance, Class Name, Function Prepend, Function Append)\n</code></pre> <p>This macro arguments are mostly the same as <code>CO_OVERRIDE_METHOD(...)</code> and  <code>CO_OVERRIDE_MEMBER_METHOD(...)</code>, only with slight differences.</p> <ol> <li><code>Class Name</code> instead of <code>Function Name</code></li> <li>Destructor version (<code>CO_OVERRIDE_MEMBER_METHOD_DTOR(...)</code>) doesn't need any <code>(Args Types)</code> nor  <code>(Args Defaults)</code>, since you cannot pass any arguments to a destructor.</li> </ol> Example <pre><code>CO_DECLARE_INSTANCE(MyOverrideInstance);\n\nclass MockMyClass\n{\n    //MockMyClass(int value1, float value2)\n    CO_OVERRIDE_MEMBER_METHOD_CTOR(MyOverrideInstance, MockMyClass, (int, float))\n\n    //virtual ~MockMyClass()\n    CO_OVERRIDE_MEMBER_METHOD_DTOR(MyOverrideInstance, MockMyClass, virtual)\n};\n</code></pre> <p>Important</p> <p>If you have comma in your return type (such as <code>std::tuple&lt;int, int&gt;</code>), you need to add an extra parenthesis to protect it against macro.</p> <p>For example: <pre><code>//std::tuple&lt;int, int&gt; MemberFunction(std::tuple&lt;int, int&gt; value1, float value2)\nCO_OVERRIDE_METHOD(MyOverrideInstance, (std::tuple&lt;int, int&gt;), MemberFunction, \n    ((std::tuple&lt;int, int&gt;), float), /* no append */)\n</code></pre></p> <p>You can also override any existing functions with <code>CO_OVERRIDE_IMPL(...)</code>.  This is what <code>CO_OVERRIDE_METHOD(...)</code> use under the hood.</p> <pre><code>CO_OVERRIDE_IMPL(Override Instance, Return Type, (Arguments))\n</code></pre> Example <pre><code>#include \"CppOverride.hpp\"\nint FreeFunction(int value1, float value2)\n{\n    CO_OVERRIDE_IMPL(MyOverrideInstance, int, (value1, value2));\n    return value1 * value2;\n}\n</code></pre> <p>For overriding member functions, you can use <code>CO_OVERRIDE_MEMBER_IMPL(...)</code>. This is what <code>CO_OVERRIDE_MEMBER_METHOD(...)</code> use under the hood.</p> <pre><code>CO_OVERRIDE_MEMBER_IMPL(Override Instance, Return Type, (Arguments))\n</code></pre> <p>For constructors and destructors:</p> <pre><code>CO_OVERRIDE_MEMBER_IMPL_CTOR_DTOR(Override Instance, (Arguments))\n</code></pre> Example <pre><code>#include \"CppOverride.hpp\"\nint SomeClass::MemberFunction(int value1, float value2)\n{\n    CO_OVERRIDE_MEMBER_IMPL(MyOverrideInstance, int, (value1, value2));\n    return value1 * value2;\n}\n\nSomeClass::SomeClass(int value1, float value2)\n{\n    CO_OVERRIDE_MEMBER_IMPL_CTOR_DTOR(MyOverrideInstance, (value1, value2));\n}\n\nSomeClass::~SomeClass()\n{\n    CO_OVERRIDE_MEMBER_IMPL_CTOR_DTOR(MyOverrideInstance, ());\n}\n</code></pre> <p>Important</p> <p>Similar to <code>CO_OVERRIDE_METHOD(...)</code>,  any type that has a comma in it needs to be protected with parenthesis</p> <p>For a function like </p> <pre><code>std::tuple&lt;int, int&gt; FreeFunction(int value1, float value2)\n</code></pre> <p>It will be</p> <pre><code>CO_OVERRIDE_IMPL(MyOverrideInstance, (std::tuple&lt;int, int&gt;), (value1, value2))\n</code></pre>"},{"location":"#4-setup-override-actions","title":"\ud83e\uddf2 4. Setup Override Actions","text":"<p>Now we have inserted the override implementations,  we will just need to interact with the override instance to control the override functions when called.</p> <p>To start setting up the override actions, call <code>CO_SETUP_OVERRIDE</code> macro <pre><code>CO_SETUP_OVERRIDE(Override Instance, Function Name);\n</code></pre></p> <p>This can be chained with different actions like this</p> <pre><code>CO_SETUP_OVERRIDE(Override Instance, Function Name)\n                 .WhenCalledWith(Values...)\n                 .Returns&lt;Return Type&gt;(Return Value);\n                 //etc...\n</code></pre> <p>We will talk about all the actions that can be done later.</p> Example <pre><code>#include \"CppOverride.hpp\"\n#include &lt;iostream&gt;\n\nCO_DECLARE_INSTANCE(MyOverrideInstance);\n\nint FreeFunction(int value1, float value2)\n{\n    CO_OVERRIDE_IMPL(MyOverrideInstance, int, (value1, value2));\n    return value1 * value2;\n}\n\nint main()\n{\n    CO_SETUP_OVERRIDE(MyOverrideInstance, FreeFunction)\n                     .WhenCalledWith(1, 2.f)\n                     .Returns&lt;int&gt;(42);\n\n    int result = FreeFunction(1, 2.f);\n    std::cout &lt;&lt; \"result: \" &lt;&lt; result &lt;&lt; std::endl; //result: 42\n\n    result = FreeFunction(2, 3.f);\n    std::cout &lt;&lt; \"result: \" &lt;&lt; result &lt;&lt; std::endl; //result: 6 (2 * 3.f)\n}\n</code></pre> <p>If you have your override instance declared inside a class or inheriting from <code>CppOverride::Overridable</code>,  pass that object as <code>Override Instance</code> instead</p> Example <pre><code>//YourClass.hpp\n#include \"CppOverride.hpp\"\nclass YourClass\n{\n    private:\n        CO_DECLARE_MEMBER_INSTANCE(MyOverrideInstance);\n        ...\n    public:\n        CO_DECLARE_OVERRIDE_METHODS(MyOverrideInstance);\n        int MemberFunction(int value1, float value2);\n        ...\n};\n\n//Or\nclass YourClass : public CppOverride::Overridable\n{\n        ...\n};\n...\n\n//main.cpp\n#include \"YourClass.hpp\"\n#include \"CppOverride.hpp\"\n#include &lt;iostream&gt;\n\nint main()\n{\n    YourClass classObject;\n\n    CO_SETUP_OVERRIDE(classObject, MemberFunction)\n                     .WhenCalledWith(1, 2.f)\n                     .Returns&lt;int&gt;(42);\n    ...\n}\n</code></pre> <p>If you want to override a function for a specific object,  you can specify with  <pre><code>CO_SETUP_OVERRIDE(Override Instance, Your Function)\n                 .OverridesObject(Your Object address)\n</code></pre></p> <p>Note</p> <p>This requires <code>CO_OVERRIDE_MEMBER_IMPL(...)</code> (Or <code>CO_OVERRIDE_MEMBER_METHOD(...)</code>)  to be used instead of <code>CO_OVERRIDE_IMPL(...)</code></p> Example <pre><code>int main()\n{\n    YourClass classObject;\n    YourClass classObject2;\n\n    CO_SETUP_OVERRIDE(classObject, MemberFunction)\n                     .WhenCalledWith(1, 2.f)\n                     .OverridesObject(&amp;classObject2)\n                     .Returns&lt;int&gt;(42);\n\n    int result = classObject.MemberFunction(1, 2.f);    //Won't override\n    result = classObject2.MemberFunction(1, 2.f);       //Will override\n}\n</code></pre>"},{"location":"#override-result","title":"Override Result","text":"<p>Everytime where there's an attempt to override the function  (assuming the function name and types match), the result of it can be recorded,  whether it was successful or not.</p> <p>You can create and bind an override result object by calling <code>ReturnsResult()</code> at the end of  <code>CO_SETUP_OVERRIDE()</code> chained actions.</p> <pre><code>CppOverride::ResultPtr result = CO_SETUP_OVERRIDE(YourOverrideInstance, YourFunction).ReturnsResult();\n</code></pre> <p><code>CppOverride::ResultPtr</code> is just a shared_ptr defined as this </p> <pre><code>using ResultPtr = std::shared_ptr&lt;OverrideResult&gt;;\n</code></pre> <p>If needed, You can create an override result object explicitly with <code>CreateOverrideResult()</code></p> <pre><code>CppOverride::ResultPtr result = CppOverride::CreateOverrideResult();\n</code></pre> <p>and explicitly bind the result object to an override action:</p> <pre><code>CO_SETUP_OVERRIDE(Override Instance, Your Function)\n                 .AssignsResult(Result Object)\n</code></pre> Info <p>The reason why shared pointer is used is because when we assign this result object to an override action, and the override instance holds the reference of it.  If the result object goes out of scope, the program will crash when  the override instance is trying to dereference and modify this result object</p> <p>Each time when there's an override attempt (whether successful or not),  it will add to the list of override status.</p> <p>To get the list of status: <pre><code>std::vector&lt;OverrideStatus&gt; statuses = result.GetAllStatuses();\n</code></pre></p> List of possible status <pre><code>enum class OverrideStatus\n{\n    //Default status.\n    //  Any matching override will modify the status to not be this value.\n    //  If the status is not modified (i.e. staying in this value), \n    //  Could be one of these reasons:\n    //  - Function name not matching\n    //  - Argument types not matching\n    //  - Return type not matching\n    NO_OVERRIDE,\n\n    //The last override was successful. \n    //  Please reset the status to NO_OVERRIDE before every expected override. \n    //  If the status is not reset, it will not be modified if no matching override is found.\n    OVERRIDE_SUCCESS,\n\n    MATCHING_CONDITION_VALUE_FAILED,\n    MATCHING_CONDITION_ACTION_FAILED,\n    MATCHING_OVERRIDE_TIMES_FAILED,\n\n    //------------------------------------------\n    //Internal error\n    //------------------------------------------\n    INTERNAL_MISSING_CHECK_ERROR,\n\n    //------------------------------------------\n    //Unsupported operation errors\n    //------------------------------------------\n    MODIFY_NON_ASSIGNABLE_ARG_ERROR,\n    MODIFY_CONST_ARG_ERROR,\n    CHECK_ARG_MISSING_INEQUAL_OPERATOR_ERROR,\n};\n</code></pre> <p>Here are a list of helper functions to perform the most common actions: <pre><code>class OverrideResult\n{\n    //Returns true if status list is not empty and last one is OVERRIDE_SUCCESS\n    bool LastStatusSucceed();\n\n    //Returns true if status list is not empty and last one is **NOT** OVERRIDE_SUCCESS\n    bool LastStatusFailed();\n\n    //Returns the last status if the status list is not empty, otherwise NO_OVERRIDE\n    OverrideStatus GetLastStatus();\n\n    //Returns true if the status list contains said status\n    bool HasStatus(OverrideStatus status);\n\n    //Returns the number of status in the status list\n    int GetStatusCount();\n\n    //Returns the number of statuses that are OVERRIDE_SUCCESS\n    int GetSucceedCount();\n\n    //Returns the number of statuses that are **NOT** OVERRIDE_SUCCESS\n    int GetFailedCount();\n\n    //Removes all the status from the status list\n    void ClearStatuses()\n\n    //Get a copy of the status list\n    std::vector&lt;OverrideStatus&gt; GetAllStatuses()\n};\n</code></pre></p> Example <pre><code>CO_DECLARE_INSTANCE(MyOverrideInstance);\nint FreeFunction(int value1, float value2);\n...\nusing namespace CppOverride;\nstd::shared_ptr&lt;OverrideResult&gt; result = CreateOverrideResult();\nCO_SETUP_OVERRIDE(MyOverrideInstance, FreeFunction)\n                 .WhenCalledWith(2, 3.f)\n                 .Returns&lt;int&gt;(1)\n                 .AssignsResult(result);\n\nint ret1 = FreeFunction(1, 2.f);\nassert(result-&gt;GetLastStatus() == OverrideStatus::MATCHING_CONDITION_VALUE_FAILED);\n\nret1 = FreeFunction(2, 3.f);\nassert(result-&gt;LastStatusSucceed());\n</code></pre> <p>You can convert the result status to string with  <pre><code>std::string OverrideStatusToString(Override Status)\n</code></pre></p>"},{"location":"#debug-override","title":"Debug Override","text":"<p>If for any reason, it is unclear why the override did not get triggered and the override result did not give any useful information. You can force CppOverride to output verbose logs by defining <code>CO_SHOW_OVERRIDE_LOG 1</code> before <code>#include \"CppOverride.hpp\"</code>. </p> <p>This will show all the debug logs on each stage of selecting override data and what conditions  are not met.</p>"},{"location":"#disable-overrides","title":"Disable Overrides","text":"<p>By default, the override implementations won't do anything if nothing is setup, which  will behave exactly as the original function.</p> <p>However, if you want zero overhead when the override is disabled, you can define <code>CO_NO_OVERRIDE</code> before including the header file.</p> <pre><code>//Just define CO_NO_OVERRIDE before including \"CppOverride.hpp\" or in compile definitions\n//So like this:\n#define CO_NO_OVERRIDE\n#include \"CppOverride.hpp\"\n</code></pre> <p>To remove the override setups for a particular function, call <code>CO_REMOVE_OVERRIDE_SETUP</code> macro</p> <pre><code>CO_REMOVE_OVERRIDE_SETUP(Override Instance, Function Name)\n</code></pre> Example <pre><code>CO_DECLARE_INSTANCE(MyOverrideInstance);\nint FreeFunction(int value1, float value2);\n...\nCO_REMOVE_OVERRIDE_SETUP(MyOverrideInstance, FreeFunction);\n</code></pre> <p>Similarly, to remove all override setups, call <code>CO_CLEAR_ALL_OVERRIDE_SETUP</code> macro</p> <pre><code>CO_CLEAR_ALL_OVERRIDE_SETUP(Override Instance)\n</code></pre> Example <pre><code>CO_DECLARE_INSTANCE(MyOverrideInstance);\n...\nCO_CLEAR_ALL_OVERRIDE_SETUP(MyOverrideInstance);\n</code></pre>"},{"location":"#override-returns","title":"Override Returns","text":"<p>You can override what a function returns by providing a value.</p> <pre><code>CO_SETUP_OVERRIDE(Override Instance, Your Function)\n                 .Returns&lt;Return Type&gt;(Return Value);\n</code></pre> Example <pre><code>int FreeFunction(int value1, float value2);\nCO_SETUP_OVERRIDE(MyOverrideInstance, FreeFunction)\n                 .Returns&lt;int&gt;(1);\n</code></pre> <p>Important</p> <p>The override return type must match exactly to the function return type,  otherwise the override will not be triggered</p> Note <p>For a function that returns void, you can also override the return to return early <pre><code>.Returns&lt;void&gt;();\n//Or .ReturnsVoid();\n</code></pre></p> <p>You can also set the return value by specifying a function, normally lambda.</p> <pre><code>CO_SETUP_OVERRIDE(Override Instance, Your Function)\n                 .ReturnsByAction&lt;Return Type&gt;\n                 (\n                    void(void* instance, const std::vector&lt;void*&gt;&amp; args, void* out) Function\n                 );\n</code></pre> <p>When the override is triggered, the function is called with the following arguments:</p> <ul> <li><code>void* instance</code>: The object that is being overridden, only set when <code>CO_OVERRIDE_IMPL_INSTANCE(...)</code> or <code>CO_OVERRIDE_IMPL_INSTANCE_CTOR_DTOR(...)</code> are used, otherwise <code>nullptr</code>.</li> <li><code>const std::vector&lt;void*&gt;&amp; args</code>: List of pointers to the arguments.  You must cast them to the original type pointers in order to use them.</li> <li><code>void* out</code>: The pointer to the return value to be returned.  You must cast it to back to return type pointer in order to use it.</li> </ul> Example <pre><code>CO_DECLARE_INSTANCE(MyOverrideInstance);\n...\nint SomeClass::MemberFunction(int value1, float value2);\n...\nCO_SETUP_OVERRIDE(MyOverrideInstance, MemberFunction)\n                 .ReturnsByAction&lt;int&gt;\n                 ( \n                     [](void* instance, const std::vector&lt;void*&gt;&amp; args, void* out)\n                     {\n                         //instance is same as \"this\" in MemberFunction\n                         std::cout &lt;&lt; \"instance: \" &lt;&lt; instance &lt;&lt; std::endl;\n\n                         //*args[0] is value1\n                         std::cout &lt;&lt; \"*args[0]: \" *static_cast&lt;int*&gt;(args.at(0)) &lt;&lt; std::endl;\n\n                         //*args[1] is value2\n                         std::cout &lt;&lt; \"*args[1]: \" *static_cast&lt;float*&gt;(args.at(1)) &lt;&lt; std::endl;\n\n                         //out is what we return\n                         *static_cast&lt;int*&gt;(out) = 42;\n                     }\n                 );\n...\nSomeClass someObject;\nstd::cout &lt;&lt; someObject.MemberFunction(1, 2.f) &lt;&lt; std::endl;    //42\n</code></pre>"},{"location":"#override-arguments-values","title":"Override Arguments Values","text":"<pre><code>CO_SETUP_OVERRIDE(Override Instance, Your Function)\n                 .SetArgs&lt;Function Argument Types&gt;(Argument Values);\n</code></pre> <p>The argument values can be a dereference version of the corresponding argument type.</p> <p>For example, an integer pointer type can be set with an integer value.</p> Example <pre><code>CO_DECLARE_INSTANCE(MyOverrideInstance);\n...\nvoid FreeFunction(float&amp; value1, int* value2);\n...\nCO_SETUP_OVERRIDE(MyOverrideInstance, FreeFunction)\n                 .SetArgs&lt;float&amp;, int*&gt;(1.f, 3);\n</code></pre> <p>Important</p> <p>The template types of the argument specified must match the function argument types exactly.</p> <p>You can also use <code>CO_ANY_TYPE</code> and <code>CO_DONT_SET</code> to not set some of the arguments.</p> Example <pre><code>CO_DECLARE_INSTANCE(MyOverrideInstance);\n...\nvoid FreeFunction(float&amp; value1, int* value2);\n...\nCO_SETUP_OVERRIDE(MyOverrideInstance, FreeFunction)\n                 .SetArgs&lt;CO_ANY_TYPE, int*&gt;(CO_DONT_SET, 3);\n</code></pre> <p>In this case, the first argument is not touched, while the second argument is set to 3.</p> Note <p>It is common to pair <code>.SetArgs</code> with <code>.Returns</code> so that the execution doesn't continue when we finish overriding the arguments.</p> <p>Given we have this <pre><code>CO_DECLARE_INSTANCE(MyOverrideInstance);\nvoid FreeFunction(float&amp; value1, int* value2)\n{\n    CO_OVERRIDE_IMPL(MyOverrideInstance, void, (value1, value2));\n    std::cout &lt;&lt; \"Rest of the OverrideMyArgs execution...\" &lt;&lt; std::endl;\n    value1 = *value2;\n    ...\n}\n...\nCO_SETUP_OVERRIDE(MyOverrideInstance, FreeFunction)\n                  .SetArgs&lt;float&amp;, int*&gt;(1.f, 3);\n...\nFreeFunction(value1, value2);\n</code></pre></p> <p>What will happen when we call the function is</p> <ol> <li>Override occurs, <code>value1</code> is set to <code>1.f</code> and <code>value2</code> is set to <code>3</code></li> <li>Execution does not stop</li> <li>Output: \"Rest of the OverrideMyArgs execution...\"</li> <li><code>value1 = *value2;</code> happens, setting <code>value1</code> to <code>*value2</code> which is <code>3</code></li> </ol> <p>To return early after we set the arguments, we can do <pre><code> CO_SETUP_OVERRIDE(MyOverrideInstance, FreeFunction)\n                  .SetArgs&lt;float&amp;, int*&gt;(1.f, 3);\n                  .Returns&lt;void&gt;();\n                  //Or .ReturnsVoid();\n</code></pre> Which will return early after step 1.</p> <p>Similar to override return,  you can also set the argument values by specifying a function, normally lambda.</p> <pre><code>CO_SETUP_OVERRIDE(Override Instance, Your Function)\n                 .SetArgsByAction&lt;Function Argument Types&gt;\n                 (\n                    void(void* instance, std::vector&lt;void*&gt;&amp; args) Function\n                 );\n</code></pre> <p>This the same as the <code>ReturnsByAction</code>, but without the need of modifying any return value. Again, you must cast the arguments pointers to their original type pointers in order to use them.</p> Example <pre><code>CO_DECLARE_INSTANCE(MyOverrideInstance);\n...\nvoid FreeFunction(float&amp; value1, int* value2);\n...\nCO_SETUP_OVERRIDE(MyOverrideInstance, FreeFunction)\n                 .SetArgsByAction&lt;float&amp;, int*&gt;\n                 (\n                     [](void* instance, std::vector&lt;void*&gt;&amp; args)\n                     {\n                         (void)instance; //This will be nullptr in this case\n\n                         //Pointer to float&amp; is just float*\n                         *static_cast&lt;float*&gt;(args.at(0)) = 1.f;\n\n                         //Pointer to int* is int**\n                         **static_cast&lt;int**&gt;(args.at(1)) = 2;\n                     }\n                 );\n</code></pre> <p>Similar to <code>.SetArgs&lt;...&gt;(...)</code>, you can use <code>CO_ANY_TYPE</code> to match any type or to indicate  that it won't be set.</p>"},{"location":"#match-object","title":"Match Object","text":"<pre><code>CO_SETUP_OVERRIDE(Override Instance, Your Function)\n                 .MatchesObject(const void* instance)\n</code></pre> <p>This triggers the override only when the object pointer matches.</p> <p>This requires the <code>CO_OVERRIDE_MEMBER_IMPL</code> or <code>CO_OVERRIDE_MEMBER_METHOD</code> macros to be inserted.</p> <pre><code>CO_SETUP_OVERRIDE(Override Instance, Your Function)\n                 .MatchesAny()\n</code></pre> <p>This explicitly set the override to ignore the object pointer. </p> <p>This is the default behavior even without calling this method.</p>"},{"location":"#when-called-with","title":"When Called With","text":"<p>This triggers the override only when the value matches.  This also auto dereference any pointer to match for the value if possible,  if not it will then try to match pointer instead.</p> <pre><code>CO_SETUP_OVERRIDE(Override Instance, Your Function)\n                 .WhenCalledWith&lt;typename... Args&gt;(Args... args)\n</code></pre> Example <pre><code>CO_DECLARE_INSTANCE(MyOverrideInstance);\nint FreeFunction(int value1, float value2);\n...\nCO_SETUP_OVERRIDE(MyOverrideInstance, FreeFunction)\n                 .WhenCalledWith(2, 3.f)\n                 .Returns&lt;int&gt;(1);\n\nint ret1 = OverrideMyReturnValue(2, 3.f);   //Returns 1\nint ret2 = OverrideMyReturnValue(1, 2.f);   //Won't return 1\n</code></pre> <p>If you don't care about a certain parameter, you can use <code>CO_ANY_TYPE</code> and <code>CO_ANY</code> to skip it</p> Example <pre><code>    CO_DECLARE_INSTANCE(MyOverrideInstance);\n    int FreeFunction(int value1, float value2);\n    ...\n    CO_SETUP_OVERRIDE(MyOverrideInstance, FreeFunction)\n                     .WhenCalledWith&lt;int, CO_ANY_TYPE&gt;(2, CO_ANY)\n                     .Returns&lt;int&gt;(1);\n\n    int ret1 = OverrideMyReturnValue(2, 3.f);   //Returns 1\n    int ret2 = OverrideMyReturnValue(2, 2.f);   //Returns 1\n</code></pre>"},{"location":"#times","title":"Times","text":"<p>This allows override to be triggered for the set amount of times.</p> <pre><code>CO_SETUP_OVERRIDE(Override Instance, Your Function)\n                 .Times(int times)\n</code></pre> Example <pre><code>CO_DECLARE_INSTANCE(MyOverrideInstance);\nint FreeFunction(int value1, float value2);\n...\nCO_SETUP_OVERRIDE(MyOverrideInstance, FreeFunction)\n                 .Times(1)\n                 .Returns&lt;int&gt;(1);\n\nint ret1 = OverrideMyReturnValue(2, 3.f);   //Returns 1\nret1 = OverrideMyReturnValue(2, 3.f);       //Won't returns 1\n</code></pre>"},{"location":"#if","title":"If","text":"<p>This sets the condition to decide to run the override action or not</p> <pre><code>CO_SETUP_OVERRIDE(Override Instance, Your Function)\n                 .If\n                 (\n                    bool(void* instance, const std::vector&lt;void*&gt;&amp; args) function\n                 )\n</code></pre> Example <pre><code>CO_DECLARE_INSTANCE(MyOverrideInstance);\nint FreeFunction(int value1, float value2);\n...\nCO_SETUP_OVERRIDE(MyOverrideInstance, FreeFunction)\n                 .If\n                 (\n                     [](void* instance, const std::vector&lt;void*&gt;&amp; args) \n                     {\n                         if(*static_cast&lt;int*&gt;(args.at(0)) == 1)\n                             return true;\n                         else\n                             return false;\n                     }\n                 )\n                 .Returns&lt;int&gt;(1);\n\nint ret1 = OverrideMyReturnValue(1, 2.f);   //Returns 1\nint ret2 = OverrideMyReturnValue(2, 3.f);   //Won't return 1\n</code></pre>"},{"location":"#when-called-expectedly-do","title":"When Called Expectedly Do","text":"<p>This allows you to setup a function callback that gets called before an override will be used</p> <pre><code>CO_SETUP_OVERRIDE(Override Instance, Your Function)\n                 .WhenCalledExpectedly_Do\n                 (\n                    void(void* instance, const std::vector&lt;void*&gt;&amp; args) function\n                 );\n</code></pre> Example <pre><code>CO_DECLARE_INSTANCE(MyOverrideInstance);\nint FreeFunction(int value1, float value2);\n...\nbool called = false;\nCO_SETUP_OVERRIDE(MyOverrideInstance, FreeFunction)\n                 .WhenCalledWith(2, 3.f)\n                 .Returns&lt;int&gt;(1)\n                 .WhenCalledExpectedly_Do\n                 (\n                     [&amp;called](void* instance, const std::vector&lt;void*&gt;&amp; args)\n                     {\n                         called = true;\n                         //...\n                     }\n                 );\n\nint ret1 = FreeFunction(1, 2.f);   //called is still false\nint ret2 = FreeFunction(2, 3.f);   //called is true and ret2 is 1 now\n</code></pre> Tip <p>If you just want to see if the function is called without overriding anything,  simple don't override anything. So like: <pre><code>CO_SETUP_OVERRIDE(MyOverrideInstance, FreeFunction)\n                 .WhenCalledWith(2, 3.f)\n                 .WhenCalledExpectedly_Do\n                 (\n                     [&amp;called](void* instance, const std::vector&lt;void*&gt;&amp; args)\n                     {\n                         called = true;\n                         //...\n                     }\n                 )\n</code></pre></p>"},{"location":"#otherwise-do-function-lambda","title":"Otherwise Do Function / Lambda","text":"<p>This allows you to setup a function callback that gets called when an override can't be used  because of failing to meet conditions or failing to match the correct argument values.</p> <pre><code>CO_SETUP_OVERRIDE(Override Instance, Your Function)\n                 .Otherwise_Do\n                 (\n                    void(void* instance, const std::vector&lt;void*&gt;&amp; args) function\n                 );\n</code></pre> Example <pre><code>CO_DECLARE_INSTANCE(MyOverrideInstance);\nint FreeFunction(int value1, float value2);\n...\nbool called = false;\nCO_SETUP_OVERRIDE(MyOverrideInstance, FreeFunction)\n                 .WhenCalledWith(2, 3.f)\n                 .Returns&lt;int&gt;(1)\n                 .Otherwise_Do\n                 (\n                     [&amp;called](void* instance, const std::vector&lt;void*&gt;&amp; args)\n                     {\n                         called = true;\n                         ...\n                     }\n                 );\n\nint ret2 = FreeFunction(2, 3.f);   //called is still false\nint ret1 = FreeFunction(1, 2.f);   //called is true now\n</code></pre>"},{"location":"#5-mock-class-generator","title":"\ud83d\udce0 5. Mock Class Generator","text":"<p>Unlike other mocking frameworks, we ship with a mock class generator that is built along with the project that parses a given header and output the equivalent mock class header.</p> <p>Do keep in mind that this is just a rough header parser so manual adjustment might still be needed. For more details, do <code>GenerateMockClass --help</code>.</p> <p>To write the output to a file on Unix do</p> <pre><code>./GenerateMockClass &lt;options...&gt; &lt;input header&gt; &gt; ./MyMockClass.hpp\n</code></pre> <p>or in Windows Powershell</p> <pre><code>./GenerateMockClass &lt;options...&gt; &lt;input header&gt; | Set-Content -Encoding UTF8NoBOM ./MyMockClass.hpp\n</code></pre>"},{"location":"#6-overriding-external-functions-and-objects","title":"\ud83d\udd0c 6. Overriding External Functions and Objects","text":"<p>It is very difficult to override external functions or objects since unlike other languages like C#, everything is compiled and there's no way to change the behavior of it.</p> <p>In order to override an external function or objects,  we first need to create an override version of it.</p> <p>Let's say we have the following external class and function.</p> <pre><code>//External Class, cannot edit this\nclass FileWriter\n{\n    public:\n        bool CreateFile(std::string fileName);\n        bool WriteContent(const std::string&amp; content);\n        bool Close();\n};\n\n//External Function, cannot edit this\nFileWriter GetDatabaseInternalWriter(std::string tableName);\n</code></pre> <p>We should create the corresponding override versions of them. </p> <pre><code>extern CO_DECLARE_INSTANCE(MyOverrideInstance);\n\nclass MockFileWritter\n{\n    public:\n    inline bool CreateFile(std::string fileName)\n    {\n        CO_OVERRIDE_IMPL_INSTANCE(MyOverrideInstance, bool, (fileName));\n        return false;\n    }\n\n    inline bool WriteContent(std::string content)\n    {\n        CO_OVERRIDE_IMPL_INSTANCE(MyOverrideInstance, bool, (content));\n        return false;\n    }\n\n    inline bool Close()\n    {\n        CO_OVERRIDE_IMPL_INSTANCE(MyOverrideInstance, bool, ());\n        return false;\n    }\n}\n\n//FileWriter GetDatabaseDataWriter(std::string tableName);\ninline MockFileWritter MockGetDatabaseInternalWriter(std::string tableName)\n{\n    CO_OVERRIDE_IMPL(MyOverrideInstance, MockFileWritter, (tableName));\n    return FileWriter();\n}\n</code></pre> <p>Let's say we have a piece of code like this in our codebase</p> <pre><code>bool WriteToDatabaseRecord(int key, const std::string&amp; data)\n{\n    FileWriter databaseWriter = GetDatabaseInternalWriter(\"UserData\");\n    if(!databaseWriter.WriteContent(std::to_string(key) + \",\" + data))\n        return false;\n\n    ...\n\n    return databaseWriter.Close();\n}\n</code></pre> <p>As you can see, we don't even hold a reference to <code>databaseWriter</code> outside of this function, let alone overriding and testing it. </p> <p>That's why it is recommended to declare the override instance in global scope. So that you can override the behavior of objects that you cannot reference in test.</p> <p>In order to override it, we would have to make some changes to this code unfortunately.</p> <p>While people would normally suggest rewriting the code using template or interface,  this normally requires a lot of rewriting and restructure to the codebase.</p> <p>Instead, we can just use the powerful (yet dangerous) preprocessing system.</p> <p>Without rewriting and restructuring, we can just</p> <pre><code>#if !defined(CO_NO_OVERRIDE) || !CO_NO_OVERRIDE\n    #define GetDatabaseInternalWriter MockGetDatabaseInternalWriter\n    #define FileWritter MockFileWritter\n#endif\n</code></pre> <p>This way, the original code is modified when testing while being untouched.</p> <p>This is what it will look like after the macro replacement.</p> <pre><code>bool WriteToDatabaseRecord(int key, const std::string&amp; data)\n{\n    MockFileWritter databaseWriter = MockGetDatabaseInternalWriter(\"UserData\");\n    if(!databaseWriter.WriteContent(std::to_string(key) + \",\" + data))\n        return false;\n\n    ...\n\n    return databaseWriter.Close();\n}\n</code></pre>"}]}